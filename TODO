
Features
--------

* good error messages

* structured verbosity

* debug information

* handle absurd patterns (how? like in agdaLight or differently?)

* Use substitutions for meta dependencies (at least for printing).  We'll need
  to remember the number (or names?) of dependency args. How to show that a
  meta variable cannot depend on a particular variable?

* imports

* lazy evaluation

Fixes
-----

[Parsing]

* allow more things in postulates (infix, private, ..)

* Check out lex/parse errors (what position and what input is reported).

[Scope]

* scope checking yields impossible when things clash
  (doesn't scope checking check for name clashes when opening? it should.)

* local modules can clash

* handle clashing of concrete names (in abstractToConcrete)

* handle command line options (import path)

[Testing]

* write better tests

* test how primitive/builtin things work together with (parameterised) modules

[Bugs]

* emacs interface gets the metas in the wrong order for local definitions (?)

[Interaction]

* check that underscores have been solved (when? at the end of the file)
  only for interactive mode and batch mode

[Errors]

* Remember/figure out range of previous binding in DuplicateBuiltinBinding.

[Type checking]

* When do we have to turn on abstractMode. When checking anything public? Not
  done at the moment.

Speculative
-----------

* make scope checking aware of abstract? or maybe this is too much work

Cleaning
--------

* TypeChecking.Reduce

* TypeChecking.Errors: redefine pretty printer combinators monadically

* Think about interaction between the different monads: Parser, Scope, TCM.
  Possible to unify?

Performance
-----------

* a lot of memory created by subst is never used

* space leak in lexer (positions too lazy?)

Done
----

* literals

* built-in things

* pragmas

* move trace to environment

* name suggestions in telescopes

* forall x y z -> A  =  (x:_)(y:_)(z:_) -> A

* cleaning up of TypeChecking.Monad.*

* Context to abstract thinks that the types are valid in the entire context.

* Hiding info on lambdas.

* flag for printing all implicit arguments (handled in internal to abstract)

* proof irrelevance

* Prop <= Set

* sort checking of datatypes check that all constructor arguments fit inside
  the datatype sort (rather than checking that the types of the constructor fit)

* let-bindings (only x = e definitions)

* insertion of hidden lambdas when appropriate

* optimise

* for an as-pattern x@p x should reduce to p during type checking

* as-patterns

* split TypeChecking.Monad.Context

* better names for implicit args in lhs

* replace explicit Hidden with Arg in Pi and App (and more?)

* independent functions in Type

* local functions

* speed up normalise

* getopts

* When instantiating a module we should generate functions for the axioms and
  constructors and probably for everything else as well (reducing to the
  instantiated versions from the instantiated module). Together with
  monomorphic constructors.

* Monomorphic constructors.

* ? should not be a valid operator characted

* actually check sorts

* Get rid of distinction between hole and underscore. Instead keep a separate
  list of which metas are interaction points.

* Blocked constructor in Terms and Types

* insert hidden arguments in lhss

* ranges in error messages

* abstract info on constraints (TCEnv instead of Context) and interaction meta
  vars.

 vim: sts=2 sw=2 ts=80
