
Todo
----

* good error messages

* structured verbosity

* debug information

* optimise

* allow more things in postulates (infix, private?, ..)

* Check out lex/parse errors (what position and what input is reported).

* check that underscores have been solved (when? at the end of the file)

* Hiding info on lambdas.

* handle absurd patterns (how? like in agdaLight or differently?)

* name suggestions in telescopes

* Use substitutions for meta dependencies (at least for printing).  We'll need
  to remember the number (or names?) of dependency args. How to show that a
  meta variable cannot depend on a particular variable?

* for an as-pattern x@p x should reduce to p during type checking

Cleaning
--------

* TypeChecking.Monad.*

* TypeChecking.Reduce

Done
----

* as-patterns

* split TypeChecking.Monad.Context

* better names for implicit args in lhs

* replace explicit Hidden with Arg in Pi and App (and more?)

* independent functions in Type

* local functions

* speed up normalise

* getopts

* When instantiating a module we should generate functions for the axioms and
  constructors and probably for everything else as well (reducing to the
  instantiated versions from the instantiated module). Together with
  monomorphic constructors.

* Monomorphic constructors.

* ? should not be a valid operator characted

* actually check sorts

* Get rid of distinction between hole and underscore. Instead keep a separate
  list of which metas are interaction points.

* Blocked constructor in Terms and Types

* insert hidden arguments in lhss

* ranges in error messages

* abstract info on constraints (TCEnv instead of Context) and interaction meta
  vars.

 vim: sts=2 sw=2 ts=80
