
Topic: Unique names in abstract syntax.

  * The names of local functions can clash and it's not clear how to
    disambiguate them if names are (qualified) strings.

  * So unique identifiers (numbers) for names sounds like a good idea.

  * Problem: Module system, in particular separate type checking and
    interface files. If names are identified by globally unique
    numbers we're in trouble.

  * Solution: qualified unique numbers. A name is a pair of a module
    and a unique number.

  * Question: How qualified (top-level modules or also sub-modules)?

  * Answer: It feels better to treat top-level modules and sub-modules
    the same as far as possible, so each module (including
    sub-modules) should have its own set of unique identifiers.

EndTopic

Topic: Module names vs. function names

  * Since there is no confusion between module names and function
    names (they can never appear in the same place) it makes sense to
    have different representations for them. For clarity if nothing
    else.

EndTopic

Topic: Figuring out what's in Syntax.Internal(New)

  * type Args = [Value]

  * xxx2str :: xxx -> Reader Int String
    Generates fresh names.

  * Values can be beta redexes. Why? Maybe it will allow a better
    reduction strategy than call-by-name. I'm not sure it matters.

  * instance Eq Value. Only variables can be equal. Not very nice.
    Make a type wrapper (or define another function).

  * addArgs = flip apply (but generically)

  * data Sort = ... | Lub Sort Sort -- do we need this?

  * data TCErr = Fatal String | PatternErr MId

    This is nice. Pattern unification failure might go away if we wait
    a bit, PatternErr is used to signal such a failure.

  * reduce is parameterised by the stuff that's in the monad. This
    will probably make it more efficient than if it had been monadic.
    We can do this since it'll never change the state.

EndTopic

Topic: Module structure of the type checker

  - Syntax
    - Internal
  - TypeChecker
  - TypeChecking/
    - Conversion
    - Reduce
    - Monad

  Where to put subst and adjust? Let's put them in Reduce for the time
  being. No, that doesn't quite work. They'll have to go in
  Substitute.

EndTopic

Topic: Structure of the signature.

  * The module system is hierarchical so it seems resonable to
    structure the signature accordingly.

  * We need to be able to look up a QName in the signature.

  * Why does it have to be hierarchical? When do we need to manipulate
    an entire subtree?

  * A problem is that QNames aren't well thought out yet. Currently a
    moduleId is a concrete name. That's not very good.

  * Let's make it flat for the time being, that should be a simple
    thing to change at a later stage.

  * We would also have to think about what happens when modules are
    instantiated (module Foo = Bar Nat), but that can also be
    postponed.

EndTopic

Topic: Debugging

  * How to make debugging smooth?

  * We need different levels of information in print-outs.

EndTopic

Topic: Generics

  * How much do we gain by the generics? Is it worth it?
  * Maybe there is a more light-weight approach.

EndTopic

Topic: n-ary application in terms.

  * Some things might be simpler with binary application. Check it
    out.

EndTopic

Topic: Meta variables

Topic: Meta variable dependencies and hidden application

  * Currently meta variable dependencies are represented as
    applications. This means that they contain hiding information.

  * Is this a problem? It does clutter up some things, but on the
    other hand it's possible that a meta variable _is_ applied to an
    hidden argument.

EndTopic

Topic: Sort meta variables

  * How can we solve them?
  * When do we have to?

  * One option could be to instantiate all unsolved (unconstrained)
    sort metas to Set.

EndTopic

Topic: Dependency juggling
  
  * Juggling parameters is a mess. There is a dire need for a nice
    clean API.

EndTopic

EndTopic

Topic: Things to think about.

  * Meta variables need to be scope checked (probably) so when
    creating a new meta we should have access to scope information.
    It'll probably be enough to annotate declarations with scope and
    make sure that the type checker updates the current scope when
    passing a definition. Not having to bother with lambda bound
    things makes it easier.

  * Check that meta variables have been solved at appropriate times.

EndTopic

 vim: sts=2 sw=2 tw=70 fdm=marker foldmarker=Topic\:,EndTopic
