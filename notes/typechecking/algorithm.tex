\documentclass[a4paper,11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{amsmath,amssymb,amsfonts}

\usepackage{proof}

\newcommand\keyword[1]{\mathbf{#1}}
\newcommand\Coloneqq{\mathrel{::=}}
\newcommand\OR{~~|~~}
\newcommand\Hid[1]{\{#1\}}
\newcommand\lam[1]{\lambda#1.\,}
\newcommand\hlam[1]{\lam{\Hid{#1}}}
\newcommand\tlam[2]{\lam{(#1:#2)}}
\newcommand\thlam[2]{\lam{\Hid{#1:#2}}}
\newcommand\ePi[3]{(#1:#2)\to#3}
\newcommand\ehPi[3]{\{#1:#2\}\to#3}
\newcommand\vPi[2]{\Pi#1:#2.\,}
\newcommand\vhPi[2]{\Pi\{#1:#2\}.\,}
\newcommand\vPiTel[1]{\Pi#1.\,}
\newcommand\vhPiTel[1]{\vPiTel{\{#1\}}}
\newcommand\Let[2]{\keyword{let}~#1~\keyword{in}~#2}
\newcommand\Set[1]{\mathsf{Set}_#1}
\newcommand\Prop{\mathsf{Prop}}
\newcommand\el{\mathsf{El}}
\newcommand\El[1]{\el_{#1}\,}

\newcommand\APP[2]{\mathsf{app}(#1,#2)}
\newcommand\HAPP[2]{\mathsf{happ}(#1,#2)}
\newcommand\Subst[3]{#1[#2/#3]}\newcommand\Subst[3]{#1[{}^#2/{}_#3]}

% Judgement forms
\renewcommand\Check[5]{#1\,;\,#2\vdash#3\uparrow#4:#5}
\newcommand\Infer[5]{#1\,;\,#2\vdash#3\downarrow#4:#5}
\newcommand\IsType[4]{#1\,;\,#2\vdash#3\uparrow#4~\mathbf{type}}
\newcommand\Equal[5]{#1\,;\,#2\vdash#3=#4:#5}
\newcommand\TEqual[4]{#1\,;\,#2\vdash#3=#4}
\newcommand\Expand[6]{#1\,;\,#2\vdash#3:#4\prec#5:#6}
\newcommand\CheckDecl[4]{#1\,;\,#2\vdash#3\to#4}

\newcommand\AddGlobalMeta[4]{#1\,;\,#2\vdash{?_{#3}}:#4}
\newcommand\AddLocalMeta[4]{#1\,;\,#2\vdash{?_{#3}}:#4}

\title{Agda II Type Checking Algorithm}
\author{Ulf Norell}

\begin{document}
\maketitle

\section{Introduction}

    Write something nice here.

\section{Syntax}

\subsection{Expressions}

    Expressions have been scope checked, but not type checked. Hence the mix
    between terms, types and sorts.

    \[\begin{array}{lcl}
	e & \Coloneqq & x \OR c \OR l \OR ? \OR \_ \\
	  & \OR & \lam xe \OR \hlam xe \OR \tlam xee \OR \thlam xee \\
	  & \OR & e\,e \OR e\,\Hid e \OR \Let{\vec\delta}e \\
	  & \OR & \ePi xee \OR \ehPi xee \OR \Set n \OR \Prop \\
	l & \Coloneqq & \mathit{integer} \OR \mathit{float} \OR \mathit{string} \OR \mathit{character} \\
    \end{array}\]

    Constants ($c$) are names of constructors, defined functions, postulates and datatypes.

\subsection{Declarations}

    \[\begin{array}{lcl}
	\delta & \Coloneqq & \ldots
    \end{array}\]

\subsection{Terms}

    Terms are type checked versions of expressions (that aren't types). The
    type checking algorithm produces one of these when type checking. The
    implementation uses deBruijn variables, but to simplify the presentation
    we don't do that here.

    \[\begin{array}{lcl}
	s,t & \Coloneqq & x \OR c \OR l \OR ?_i \\
	    & \OR & \lam xt \OR \hlam xt \OR s\,t \OR s\,\Hid t
    \end{array}\]

    Worth noting is that meta variables are now named and that there are no
    typed lambdas left.

\subsection{Types and Sorts}

    After type checking we distinguish between terms, types and sorts.

    \[\begin{array}{lcl}
	A,B & \Coloneqq & \El\alpha t \OR \vPi xAB \OR \vhPi xAB \OR \alpha \\
	\alpha,\beta & \Coloneqq & \Set n \OR \Prop \OR \alpha\sqcup\beta \\
    \end{array}\]

    In some presentation of the system design we had type and sort meta
    variables. I will try to do without them. What this means is that we can't,
    for instance, infer the type of a domain-free lambda by introducing a meta
    variable for the domain type.

    The reason for not having type meta variables is that I'm not sure how they
    interact with coercions.  Depending on the order you solve constraints you
    might end up with different instantiations (since different coercions were
    applied).  It might be that it doesn't matter, but until we're sure I
    prefer to err on the side of caution.

\section{Judgement forms}

    In the judgement forms below $\Sigma$ is the signature and contains the
    type and definition (if any) of the constants currently in scope. $\Gamma$
    is the context and contains the types of the bound variables.

    \[\begin{array}{ll}
	\Check\Sigma\Gamma etA	    & \mbox{Type checking, computes $t$.} \\
	\Infer\Sigma\Gamma etA	    & \mbox{Type inference, computes $t$ and $A$.} \\
	\IsType\Sigma\Gamma eA	    & \mbox{Checking that $e$ is a type, computes $A$.} \\
	\Equal\Sigma\Gamma stA	    & \mbox{Typed conversion.} \\
	\TEqual\Sigma\Gamma AB	    & \mbox{Type conversion.} \\
	\Expand\Sigma\Gamma sAtB    & \mbox{Coercing conversion, computes $t$.} \\
	\CheckDecl\Sigma\Gamma\delta{\Sigma'} & \mbox{Checking declarations, computes $\Sigma'$.}
    \end{array}\]

    The only non-standard judgement is the coercing conversion. The purpose of
    this judgement form is to insert things that have been hidden. For
    instance, suppose that $f:\vhPi A{\Set0}\vPi xAA$ in $\Sigma$ and we want
    to check $\Check\Sigma\Gamma ft{\vPi xBB}$. This should succeed with $t =
    f\,\Hid{B}$. The reason it does succeed is because we can coerce $f$ to
    have the desired type:
    \[
	\Expand\Sigma\Gamma f{\vhPi A{\Set0}\vPi xAA}{f\,\Hid{B}}{\vPi xBB}
    \]

\section{Judgements}

\subsection{Checking}

    Type checking is used only as a last resort. If we can infer the type,
    that's what we do.

    \[\begin{array}{c}
	\infer{ \Check\Sigma\Gamma etB }
	{ \Infer\Sigma\Gamma esA
	& \Expand\Sigma\Gamma sAtB
	}
    \end{array}\]

    The coercing conversion inserts any hidden lambdas or applications that are
    missing from $s$.

    We can't infer the type of domain free lambdas.

    \[\begin{array}{c}
	\infer{ \Check\Sigma\Gamma{\lam xe}{\lam xt}{\vPi xAB} }
	      { \Check\Sigma{\Gamma,x:A}etB }
	\\{}\\
	\infer{ \Check\Sigma\Gamma{\hlam xe}{\hlam xt}{\vhPi xAB} }
	      { \Check\Sigma{\Gamma,x:A}etB }
    \end{array}\]

    If we're checking a non-hidden lambda against a hidden function type we
    should insert the appropriate number of hidden lambdas. There is some
    abuse of notation to make the rule more readable: If $\Delta =
    (x_1:A_1)\ldots(x_n:A_n)$, then $\hlam\Delta t$ means $\hlam{x_1}\ldots\hlam{x_n}t$ and
    $\vhPiTel\Delta B$ means $\vhPi{x_1}{A_1}\ldots\vhPi{x_n}{A_n}B$.

    \[\begin{array}{c}
	\infer{ \Check\Sigma\Gamma{\lam xe}{\hlam\Delta\lam xt}{\vhPiTel\Delta\vPi xAB} }
	{ \Check\Sigma{\Gamma,\Delta,x:A} etB
	}
    \end{array}\]

    The type of meta variables can't be inferred either.

    \[\begin{array}{ccc}
	\infer[\AddGlobalMeta\Sigma\Gamma iA]{\Check\Sigma\Gamma{{?}}{{?_i}}A}{}
	    &&
	\infer[\AddLocalMeta\Sigma\Gamma iA]{\Check\Sigma\Gamma\_{{?_i}}A}{}
    \end{array}\]

    Let bindings can be inferred only if the body can be inferred, so we need a
    checking rule in case it can't.

    \[\begin{array}{c}
	\infer{ \Check\Sigma\Gamma{\Let\delta e}tA }
	{ \CheckDecl\Sigma\Gamma\delta{\Sigma'}
	& \Check{\Sigma'}\Gamma etA
	}
    \end{array}\]

    An alternative approach would be to infer the type of everything, inserting
    meta variables when we don't know.  This would require type and sort meta
    variables, though.

\subsection{Inference}

    Inferring the type of a variable or a constant amounts to looking it up in
    the context or signature. This will never fail, since the expressions have
    been scope checked prior to type checking.

    \[\begin{array}{ccc}
	\infer{\Infer\Sigma\Gamma xx{\Gamma(x)}}{} &&
	\infer{\Infer\Sigma\Gamma cc{\Sigma(x)}}{}
    \end{array}\]

    Literals have predefined types.
    \[\begin{array}{c}
	\infer{\Infer\Sigma\Gamma ll{\mathsf{typeof}(l)}}{}
    \end{array}\]

    There are three rules for application. The first two are for the easy cases
    where all implicit arguments have been made explicit.
    \[\begin{array}{c}
	\infer{ \Infer\Sigma\Gamma{e_1\,e_2}{\APP st}{\Subst Btx} }
	{ \Infer\Sigma\Gamma{e_1}s{\vPi xAB}
	& \Check\Sigma\Gamma{e_2}tA
	}
	\\{}\\
	\infer{ \Infer\Sigma\Gamma{e_1\,\Hid{e_2}}{\HAPP st}{\Subst Btx} }
	{ \Infer\Sigma\Gamma{e_1}s{\vhPi xAB}
	& \Check\Sigma\Gamma{e_2}tA
	}
    \end{array}\]
    The functions $\APP --$ and $\HAPP --$ perform $\beta$-reductions if
    necessary and otherwise act as syntactic application.

\subsection{Is type}

\subsection{Coercing conversion}

\subsection{Conversion}

\subsection{Type conversion}

\subsection{Declarations}

\end{document}
