
% Administrative
\newcommand\TODO[1]{\par{
    \setbox0=\vbox{{\small \parbox{35mm}{#1}}} %{\parbox{3.5cm}{{\small #1}}}
    \hskip-45mm\copy0
    \vskip-\ht0
    \vskip-2mm
}\par
}

% Misc
\newcommand\Or{~~|~~}
\newcommand\C{\mathcal C}
\newcommand\Pair[1]{\langle#1\rangle}

% Syntax
\newcommand\SET{\mathsf{Set}}
\newcommand\EL{\mathsf{El}\,}
\newcommand\unify{\mathsf{unify}}
\newcommand\inscope{\mathsf{InScope}}
\newcommand\PI[2]{(#1:#2)\to{}}
\newcommand\LAM[1]{\lambda #1.{}}
\newcommand\Meta[1]{{?_{#1}}}

\newcommand\Subst[3]{ {#1} [ {#3} / {#2} ] }
\newcommand\SubstD[2]{{#1} [ {#2} ] }

% Judgement forms

% Core
\newcommand\IsSigCS[1]{\vdash_{#1}}
\newcommand\IsCtxCS[2]{#2\vdash_{#1}}
\newcommand\IsTypeCS[3]{#2\vdash_{#1}#3}
\newcommand\HasTypeCS[4]{#2\vdash_{#1}#3:#4}
\newcommand\CheckTypeCS[4]{#2\vdash_{#1}#3\uparrow#4}
\newcommand\InferTypeCS[4]{#2\vdash_{#1}#3\downarrow#4}
\newcommand\EqualTypeCS[4]{#2\vdash_{#1}#3=#4}
\newcommand\EqualCS[5]{#2\vdash_{#1}#3=#4:#5}

\newcommand\IsCtxC[1]{\IsCtxCS{}{#1}}
\newcommand\IsTypeC[2]{\IsTypeCS{}{#1}{#2}}
\newcommand\HasTypeC[3]{\HasTypeCS{}{#1}{#2}{#3}}
\newcommand\CheckTypeC[3]{\CheckTypeCS{}{#1}{#2}{#3}}
\newcommand\InferTypeC[3]{\InferTypeCS{}{#1}{#2}{#3}}
\newcommand\EqualTypeC[3]{\EqualTypeCS{}{#1}{#2}{#3}}
\newcommand\EqualC[4]{\EqualCS{}{#1}{#2}{#3}{#4}}

% With metas
\newcommand\Cs{\mathcal{C}}

\newcommand\Ext[1]{{#1},\,{}}

\newcommand\ExplicitJudgement[6]{
    \langle {#1} \mathrel ; {#2} \mathrel ; {#3} \rangle
    ~{#4} \longrightarrow \langle {#5} \mathrel ; {#6} \rangle
}

\newcommand\MetaDeclS[3]{{#1} \vdash {#2} : {#3}}
\newcommand\MetaDecl[2]{\MetaDeclS \Sigma {#1} {#2}}

\newcommand\IMetaDeclS[4]{{#1} \vdash {#2} : {#3} = {#4}}
\newcommand\IMetaDecl[3]{\IMetaDeclS \Sigma {#1} {#2} {#3}}

\newcommand\ConstDeclS[5]{{#1} \vdash {#2} : {#3} = {#4} ~\mathbf{when}~ {#5}}
\newcommand\ConstDecl[4]{\ConstDeclS \Sigma {#1} {#2} {#3} {#4}}

\newcommand\AddMeta[2]{\mathsf{AddMeta}({#1} : {#2})}
\newcommand\AddConst[4]{\mathsf{AddConst}({#1} : {#2} = {#3},\,{#4})}
\newcommand\InstMeta[2]{{#1} := {#2}}
\newcommand\LookupType[2]{\mathsf{Lookup}({#1} : {#2})}
\newcommand\InScope[2]{\mathsf{InScope}_{#1}({#2})}
\newcommand\SolveConstraints{\mathsf{SolveConstraints}}
\newcommand\WithSig[1]{\langle {#1} \rangle \,}
\newcommand\UpdateGuard[2]{\mathsf{UpdateGuard}( {#1},\, {#2} )}

\newcommand\CheckTypeCtx[4]{{#1} \vdash {#2} \uparrow {#3} \leadsto {#4}}
\newcommand\InferTypeCtx[4]{{#1} \vdash {#2} \downarrow {#3} \leadsto {#4}}
\newcommand\EqualTypeCtx[4]{{#1} \vdash {#2} = {#3} \leadsto {#4}}
\newcommand\EqualCtx[5]{{#1} \vdash {#2} = {#3} : {#4} \leadsto {#5}}
\newcommand\EqualWhnfCtx[5]{{#1} \vdash {#2} \doteq {#3} : {#4} \leadsto {#5}}

\newcommand\CheckType[3]{\CheckTypeCtx \Gamma {#1} {#2} {#3}}
\newcommand\InferType[3]{\InferTypeCtx \Gamma {#1} {#2} {#3}}
\newcommand\EqualType[3]{\EqualTypeCtx \Gamma {#1} {#2} {#3}}
\newcommand\Equal[4]{\EqualCtx \Gamma {#1} {#2} {#3} {#4}}
\newcommand\EqualWhnf[4]{\EqualWhnfCtx \Gamma {#1} {#2} {#3} {#4}}

\newcommand\whnf[2]{{#1} \to_{\mathit{whnf}} {#2}}

\newcommand\FV[1]{\mathsf{FV}({#1})}

\newcommand\Rules[2]{
\par~\par
{\setlength\parindent{0mm}
    {\em #1}
    \[\begin{array}{c}
	#2
    \end{array}\]
}}

