% Implicit arguments
% Author: Catarina Coquand and Ulf Norell

%\documentclass[12pt,a4paper]{amsart}
\documentclass[11pt]{article}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}


\usepackage{epsf}
\usepackage{epsfig}
%\usepackage{isolatin1}
%\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
\usepackage{amssymb,amsmath}
\usepackage{stmaryrd}

\input{macros}

\title{Implicit Arguments}
\author{Catarina Coquand and Ulf Norell}
\date{\today}

\begin{document}


\maketitle

\section{Core}

\[\begin{array}{lclr}
    A	   & ::= & \SET \Or \EL M \Or \PI xAA		& \mathit{types} \\
    M	   & ::= & x \Or c \Or f \Or M\,M \Or \LAM xM	& \mathit{terms} \\
    \Gamma & ::= & () \Or \Gamma,x:A			& \mathit{contexts} \\
    \Sigma & ::= & () \Or \Sigma,c:A \Or \Sigma,f:A=M	& \mathit{signatures} \\
\end{array}\]

 There are six kinds of judgement
\[\begin{array}{ll}
    \IsSigCS\Sigma & \mbox{$\Sigma$ is a valid signature} \\
    \IsCtxCS\Sigma\Gamma & \mbox{$\Gamma$ is a valid context} \\
    \IsTypeCS\Sigma\Gamma A & \mbox{$A$ is a valid type in $\Gamma$} \\
    \HasTypeCS\Sigma\Gamma MA & \mbox{$M$ has type $A$ in $\Gamma$} \\
    \EqualTypeCS\Sigma\Gamma AB & \mbox{$A$ and $B$ are convertible types in $\Gamma$}\\
    \EqualCS\Sigma\Gamma MNA & \mbox{$M$ and $N$ are convertible terms of type $A$ in $\Gamma$} \\
\end{array}\]

 We will leave $\Sigma$ implicit whenever possible.
% **PJ060630: an early example of what is \Sigma is inteded for and
% how expressive/restricted it is would be very clarifying.
% (Recursion? incosistent axioms? etc.)

 The typing rules are as follows:

\medskip

 {\em rules for signatures}

\[\begin{array}{ccccc}
    \infer{\IsSigCS{()}}{}
&&  \infer{\IsSigCS{\Sigma,c:A}}{
      \IsSigCS\Sigma
    & \IsTypeCS\Sigma{()}A
    }
&&  \infer{\IsSigCS{\Sigma,f:A=M}}{
      \IsSigCS\Sigma
    & \IsTypeCS\Sigma{()}A
    & \HasTypeCS\Sigma{()}MA
    }
\end{array}\]

 {\em rules for contexts}

\[\begin{array}{ccc}
    \infer{\IsCtxCS\Sigma{()}}{\IsSigCS\Sigma}
&&  \infer{\IsCtxC{\Gamma,x:A}}{
      \IsCtxC\Gamma
    & \IsTypeC\Gamma A
    }
\end{array}\]

 {\em rules for types}

\[\begin{array}{ccccc}
    \infer{\IsTypeC\Gamma\SET}{\IsCtxC\Gamma}
&&  \infer{\IsTypeC\Gamma{\EL M}}{\HasTypeC\Gamma M\SET}
&&  \infer{\IsTypeC\Gamma{\PI xAB}}{\IsTypeC{\Gamma,x:A}B}
\end{array}\]

 {\em rules for terms}

\[\begin{array}{ccccc}
    \infer{\HasTypeC\Gamma xA}{
      \IsCtxC\Gamma
    & x:A\in\Gamma
    }
&&  \infer{\HasTypeCS\Sigma\Gamma cA}{
    & \IsCtxC\Gamma
    & c:A\in\Sigma
    }
&&  \infer{\HasTypeCS\Sigma\Gamma fA}{
      \IsCtxC\Gamma
    & f:A=M\in\Sigma
    }
\\{}\\
\multicolumn5c{\begin{array}{ccc}
    \infer{\HasTypeC\Gamma{\LAM xM}{\PI xAB}}{
      \HasTypeC{\Gamma,x:A}MB
    }
&&  \infer{\HasTypeC\Gamma{M\,N}{\Subst BxN}}{
      \HasTypeC\Gamma M{\PI xAB}
    & \HasTypeC\Gamma NA
    }
\end{array}}
\\{}\\
&&
    \infer{\HasTypeC\Gamma MB}{
      \HasTypeC\Gamma MA
    & \EqualTypeC\Gamma AB
    }
\end{array}\]

  {\em general converion rules}

\[\begin{array}{c}
\begin{array}{ccccc}
    \infer{\EqualTypeC\Gamma AA}{\IsTypeC\Gamma A}
&&  \infer{\EqualTypeC\Gamma BA}{\EqualTypeC\Gamma AB}
&&  \infer{\EqualTypeC\Gamma AC}{\EqualTypeC\Gamma AB & \EqualTypeC\Gamma BC}
\end{array} \\{}\\
\begin{array}{ccccc}
    \infer{\EqualC\Gamma MMA}{\HasTypeC\Gamma MA}
&&  \infer{\EqualC\Gamma NMA}{\EqualC\Gamma MNA}
&&  \infer{\EqualC\Gamma MPA}{\EqualC\Gamma MNA & \EqualC\Gamma NPA}
\end{array} \\{}\\
\begin{array}{ccc}
    \infer{\EqualC\Gamma MNB}{\EqualC\Gamma MNA & \EqualTypeC\Gamma AB}
&&  \infer{\EqualTypeC\Gamma{\Subst BxM}{\Subst BxN}}{
      \IsTypeC{\Gamma,x:A}B
    & \EqualC\Gamma MNA
    }
\end{array}
\end{array}\]

  {\em conversion rules for type theory}

\[\begin{array}{c}
\begin{array}{ccccc}
    \infer{\EqualTypeC\Gamma\SET\SET}{}
&&  \infer{\EqualTypeC\Gamma{\EL M}{\EL N}}{\EqualC\Gamma MN\SET}
&&  \infer{\EqualTypeC\Gamma{\PI x{A_1}{B_1}}{\PI x{A_2}{B_2}}}{
      \EqualTypeC\Gamma{A_1}{A_2}
    & \EqualTypeC{\Gamma,x:A_2}{B_1}{B_2}
    }
\end{array}
\\{}\\
    \infer{\EqualC\Gamma{\LAM xM}{\LAM xN}{\PI xAB}}{\EqualC{\Gamma,x:A}MNB}
\\{}\\
    \infer{\EqualC\Gamma{M_1\,N_1}{M_2\,N_2}{\Subst Bx{N_1}}}{
      \IsTypeC{\Gamma,x:A}B
    & \EqualC\Gamma{M_1}{M_2}{\PI xAB}
    & \EqualC\Gamma{N_1}{N_2}A
    }
\\{}\\
\begin{array}{ccc}
    \infer{\EqualC\Gamma{(\LAM xM)\,N}{\Subst MxN}{\Subst BxN}}{
      \HasTypeC{\Gamma,x:A}MB
    & \HasTypeC\Gamma MA
    }
&&  \infer{\EqualC\Gamma M{\LAM xM\,x}{\PI xAB}}{
      \IsTypeC\Gamma A
    & \HasTypeC\Gamma M{\PI xAB}
    }
\end{array}
\\{}\\
    \infer{\EqualCS\Sigma\Gamma fMA}{f:A=M \in \Sigma}
\end{array}\]

 In this presentation of rules, we consider $\lambda$ terms up to  $\alpha$-conversion.

% \subsection{Type checking}
%
% $$
% \frac{(x{:}A)~\in~\Gamma}{\Gamma\vdash x\downarrow A}~~~~~~~~~
% \frac{\Gamma\vdash M\downarrow (x{:}A)\rightarrow B~~~~\Gamma\vdash N\uparrow A}
%      {\Gamma\vdash M~N\downarrow B(x=N)}
% $$
% and
% $$
% \frac{\Gamma,x{:}A\vdash M\uparrow B}{\Gamma\vdash \lambda x.M\uparrow (x{:}A)\rightarrow B}~~~~
% \frac{\Gamma\vdash M\downarrow A~~~~\Gamma\vdash A = B}{\Gamma\vdash M\uparrow B}
% $$
%
% $$
% \frac{}{\Gamma\vdash \SET\downarrow}~~~~
% \frac{\Gamma\vdash M\downarrow\SET}{\Gamma\vdash \EL~M\downarrow}~~~~~~
% \frac{\Gamma\vdash A\downarrow~~~~~\Gamma,x{:}A\vdash B\downarrow}{\Gamma\vdash (x{:}A)\rightarrow B\downarrow}
% $$
%
% \begin{theorem}
% If $M$ is in $\beta$-normal form and $\HasTypeC\Gamma MA$ then $\Gamma\vdash M\uparrow A$.
% \end{theorem}
%

\section{Implicit Core}

Meta variables in Implicit Core are represented by function symbols. We
will use $\Meta n$ for these function symbols to distinguish them from
constants ($c$) and defined functions ($f$).
%**PJ060630: the defined ``functions'' don't need to have function
% type as I understand it. ((f : A = M) could be \in Sigma for any A)

We define a type checking algorithm for implicit core which produces a set of
constraints of the form $\Constr\Sigma\Gamma MNA$. The algorithm consist of the
following judgement forms:

\[\begin{array}{ll}
    \IsTypeIS\C\Sigma\Gamma A & \mbox{check that $A$ is a type} \\
    \CheckTypeIS\C\Sigma\Gamma MA & \mbox{check that $M$ has type $A$} \\
    \InferTypeIS\C\Sigma\Gamma MA & \mbox{infer the type of $M$} \\
    \EqualTypeIS\C\Sigma\Gamma AB & \mbox{check that $A$ and $B$ are equal} \\
    \EqualIS\C\Sigma\Gamma MNA & \mbox{check that $M$ and $N$ are equal} \\
\end{array}\]

The algorithm is the obvious extension of the Core type checking algorithm with the extra rules

\[\begin{array}{c}
    \infer{\EqualIS{\Constr\Sigma\Gamma{\Meta n\,\vec N}MA}\Sigma\Gamma{\Meta n\,\vec N}MA}{}
\\{}\\
    \infer{\EqualIS{\Constr\Sigma\Gamma M{\Meta n\,\vec N}A}\Sigma\Gamma{\Meta n\,\vec N}MA}{}
\end{array}\]

\begin{definition}
    We say that $\C$ is a set of constraints {\em over} a signature $\Sigma$ if
    for all constraints $\Constr{\Sigma'}\Gamma MNA\in\C$ it is the case that
    $\Sigma'$ is a prefix of $\Sigma$. The constraints generated by the type checking
    algorithm are always over the given signature.
\end{definition}

\begin{definition}[Instantiation]
    We say that $\gamma$ is an {\em instantiation} of a well-formed signature
    $\Sigma$, written $\gamma:\Sigma$, if it to some of the meta-variables
    $\Meta n$ in $\Sigma$ assigns terms $M$ such that the signature acquired by
    replacing $\Meta n:A$ by $\Meta n:A=M$ is well-formed in Core. We write
    $\gamma\Sigma$ for this instantiated signature.  Furthermore we require the
    terms to be normal forms with respect to $\gamma\Sigma$. For technical
%**PJ060630: normal form mentioned without a definition
    reasons we allow an instantiation to instantiate meta-variables which are
    already defined in $\Sigma$. In this case the instantiation takes
    precedence.

    If $\gamma$ assigns terms to all meta-variables in $\Sigma$ we say that
    $\gamma$ is a {\em complete instantiation}.
\end{definition}

\begin{definition}[Solution]
    An instantiation $\gamma:\Sigma$ is a {\em solution} to a set of
    constraints $\C$ over $\Sigma$, written $\gamma\Solves\C$, if for all
    $\Constr{\Sigma'}\Gamma MNA\in\C$ it is the case that
    $\EqualCS{\gamma{\Sigma'}}\Gamma MNA$.
\end{definition}

Note that if $\gamma:\Sigma$ and $\Sigma'$ is a prefix of $\Sigma$ then $\gamma:\Sigma'$.

\begin{definition}[Weak-head reduction]
    We write $\whnfS\Sigma\Gamma MNA$ when $M$ reduces to the weak-head normal
    form $N$. By definition $\HasTypeC\Gamma MA$ and $\HasTypeC\Gamma NA$.
\end{definition}
%**PJ060630: ``reduces'' and ``weak-head normal form'' not defined

\begin{theorem}[Soundness]\label{typeCheckSoundThm}
    If $\CheckTypeIS\C\Sigma\Gamma MA$ and $\gamma\Solves\C$ then $\HasTypeCS{\gamma\Sigma}\Gamma MA$.
\end{theorem}

\begin{proof}
    By simultaneous induction on the derivations.
\end{proof}

\begin{theorem}[Completeness]\label{typeCheckCompleteThm}
    If $\HasTypeCS{\gamma\Sigma}\Gamma MA$ then $\CheckTypeIS\C\Sigma\Gamma MA$ and $\gamma\Solves\C$.
\end{theorem}

\begin{proof}
    Following the completeness proof for the Core type checking algorithm.
\end{proof}

\subsection{Unification}

\begin{definition}[Constraint simplification]
    Given a set of constraints $\C$ over a signature $\Sigma$ and an
    instantiation $\gamma:\Sigma$ we can simplify $\C$ with respect to $\gamma$
    obtaining a new set of constraints, $\Simplify\gamma\C$, defined by
    \[
	\Simplify\gamma\C = \bigcup\,\{\C' ~|~ \Constr\Sigma\Gamma MNA\in\C, \EqualIS{\C'}{\gamma\Sigma}\Gamma MNA\}
    \]
\end{definition}

\begin{definition}[Dependency map]
    A {\em dependency map} $\Phi$ maps a meta-variable, $\Meta n$, to a set of
    argument indices, $\PhiSet n$, which an instantiation of the meta-variable
    cannot use.  Given a dependency map $\Phi$ and a sequence of arguments
    $\overline M$ to a meta-variable $\Meta n$ we define the arguments from
    $\overline M$ that can be used by $\Meta n$ by
    \(\PhiArgs n{\overline M} = [ M_i ~|~ i\notin\PhiSet n]\)
\end{definition}

\begin{definition}[Free variables]
    The set of free variables of a term $M$ with respect to a dependency map
    $\Phi$ is written $\FV\Phi M$. For a meta-variable application it is defined as
    $\FV\Phi{\Meta n\,\overline M} = \FV\Phi{\PhiArgs n{\overline M}}$.
\end{definition}

\begin{definition}
    Given $\gamma:\Sigma$, a meta-variable $\Meta n$, and a term $M$, if
    $\gamma$ does not define $\Meta n$, $\InScope\Sigma{\Meta n}M$ and
    $\HasTypeCS{\gamma\Sigma}{()}M{\Sigma(\Meta n)}$ we can extend $\gamma$
    with $\Meta n = M$, written $\SubstUpdate\gamma nM$. To preserve the
    invariant that instantiations only give normal terms we normalise $\gamma$
    with respect to the new binding.
\end{definition}
%**PJ060630: normalize not defined

\begin{definition}
    An instantiation $\gamma:\Sigma$ is an extension of an instantiation $\gamma'$,
    written $\gamma'\leq\gamma$ if for each $\gamma'(\Meta n) = M$ we have
    $\gamma(\Meta n) = M'$ and $\Normalise{\gamma\Sigma}M{M'}$.
\end{definition}

The unification algorithm is given by the following three rules.

% **PJ060630: the new judgement form (the ``type'' of unification) is
% not presented before use.

\[
\begin{array}{cc}
\infer{\Unify{}{\Phi}{\gamma}{\{C\} \cup \C}{\gamma'}}
{\Indep{\Phi}{C}{\Phi'}
 &
 \Unify{}{\Phi'}{\gamma}{\{C\} \cup \C}{\gamma'}
}
\end{array}
\]


\[
\begin{array}{ccccc}
\infer{\Unify{}\Phi\gamma{\Constr\Sigma\Gamma{\Meta{n}\,\overline{M}}{N}{A}\cup\C}{\gamma''}}
 { \begin{array}[b]{l}
	\PhiArgs n{\overline M} = \overline x \\
	\Meta n\notin MV(N) \\
	\FV{\Phi}N\subseteq\overline x \\
	\InScope\Sigma{\Meta n}N
    \end{array}
 &  \gamma' = \SubstUpdate{\gamma}{n}{\LAM{\overline{M}}N}
 &  \Unify{}{\Phi}{\gamma'}{\Simplify{\gamma'}\C}{\gamma''}
 }
\end{array}
\]
where $\overline{x}$ are distinct variables.


\[
\infer{\Unify\Sigma\Phi\gamma\varnothing\gamma}{\gamma~\mbox{complete w.r.t. $\Sigma$}}
\]

Computing the arguments on which meta-variables do not depend.
%**PJ060630: ...nor is this judgement form

\[
\begin{array}{cc}
\infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}{\Meta{n}\overline{M}}{N}{A}}
      {\UIndep{\Phi}{n}{i}{x_i \not\in \FV\Phi N}}}
{\PhiArgs n{\overline M} = \overline{x} & \Meta{n} \not \in MV(N)}
\end{array}
\]


\[
\begin{array}{cc}
\infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}MNA}{\Phi'}}
{\Indep{\Phi}{\proj{\FV\Phi M}N}{\Phi'}}
\end{array}
\]

\[
\begin{array}{cc}
\infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}{\Meta{n} \overline{M}}{\Meta{n} \overline{N}}{A}}{\UIndep{\Phi}{n}{i}{x_i \neq y_i}}}
{\PhiArgs n{\overline{M}} = \overline{x} & \PhiArgs n{\overline{N}} = \overline{y}}
\end{array}
\]


\[ \begin{array}{ccc}
\infer{\Indep{\Phi}{\proj{X}{y\,\overline{M}}}{\Phi'}}
{y \in X & \Indep{\Phi}{\proj{X}{\overline{M}}}{\Phi'}}
&&
\infer{\Indep{\Phi}{\proj{X}{f\,\overline{M}}}{\Phi'}}
{\Indep{\Phi}{\proj{X}{\overline{M}}}{\Phi'}}
\end{array} \]

\[
\infer{\Indep{\Phi}{\proj{X}{\Meta{n}\,\overline{M}}}{\UIndep{\Phi}{n}{i}{x_i \notin X}}}
{\PhiArgs n{\overline{M}} = \overline{x}}
\]

\[
\infer{\Indep{\Phi}{\proj{X}{\LAM yM}}{\Phi'}}
{\Indep{\Phi}{\proj{X\cup \{y\}}{M}}{\Phi'}}
\]

\begin{lemma}\label{simplifySolvesLem}
    If $\gamma'\leq\gamma$ then
    \(\gamma\Solves\Simplify{\gamma'}\C\) iff \(\gamma\Solves\C\)
\end{lemma}

\begin{proof}
    First observe that since $\gamma'\leq\gamma$ we have $\gamma\gamma'\Sigma =
    \gamma\Sigma$.

    {\em Forward direction.} Take $\Constr\Sigma\Gamma MNA\in\C$. Since
    $\Simplify{\gamma'}\C$ is well-formed we have
    $\EqualIS{\C'}{\Simplify{\gamma'}\Sigma}\Gamma MNA$ where
    $\C'\subseteq\Simplify{\gamma'}\C$. From soundness of the type checking
    algorithm (Theorem~\ref{typeCheckSoundThm}) and the fact that
    $\gamma\Solves\C'$ we conclude that $\EqualCS{\gamma\Sigma}\Gamma MNA$ and
    hence $\gamma\Solves\C$.

    {\em Backwards direction.}
    We have $\Simplify{\gamma'}\C = \C_1\cup\ldots\cup\C_k$ where for each
    $\C_i$, $\EqualIS{\C_i}{\Simplify{\gamma'}\C}\Gamma MNA$ for some
    $\Constr\Sigma\Gamma MNA\in\C$. Since $\gamma\Solves\C$ we have
    $\EqualCS{\gamma\Sigma}\Gamma MNA$, and so by completeness of the type
    checking algorithm (Theorem~\ref{typeCheckCompleteThm})
    $\EqualIS{\C'}{\Simplify{\gamma'}\C}\Gamma MNA$ where $\gamma\Solves\C'$.
    The type checking algorithm is deterministic so $\C' = \C_i$. We conclude
    that $\gamma\Solves\Simplify{\gamma'}\C$.
\end{proof}

\begin{lemma}\label{leqSolvesLem}
    If $\gamma'\leq\gamma$ then \(\gamma'\Solves\C\implies\gamma\Solves\C\).
\end{lemma}

\begin{theorem}[Soundness]\label{unifySoundThm}
    For all $\gamma$ and $\Phi$ we have
    \[\Unify{}\Phi\gamma\C\gamma' \implies \gamma\leq\gamma' \wedge \gamma'\Solves\C\]
\end{theorem}

\begin{proof}
    By induction on the derivation. In the instantiation step we have to prove that
    \[\gamma\leq\gamma'' \wedge \gamma''\Solves\{\Constr\Sigma\Gamma{\Meta n\,\overline M}NA\}\cup\C
    \]
    given that $\gamma''\Solves\Simplify{\gamma'}\C$ and $\gamma'\leq\gamma''$.
    We have $\gamma\leq\gamma''$ since $\gamma'\leq\gamma''$ and $\gamma'$ is
    an extension of $\gamma$. By Lemma \ref{simplifySolvesLem} we have that $\gamma''\Solves\C$.
    Since \(\Convertible{\gamma'\Sigma}{\Meta n\,\overline M}N\) we have
    \(\gamma'\Solves\{\Constr\Sigma\Gamma{\Meta n\,\overline M}NA\}\) and hence
    (by Lemma~\ref{leqSolvesLem}) \(\gamma''\Solves\{\Constr\Sigma\Gamma{\Meta
    n\,\overline M}NA\}\).
\end{proof}

\begin{definition}[Respect]
    We say that $\gamma\respects\Phi$ if for each $\Meta n = \LAM{\overline
    x}M$ in $\gamma$ we have \[i\in\PhiSet n\implies x_i\notin\FV{}M \]
\end{definition}

\begin{definition}[Valid]
    A dependency map $\Phi$ is {\em valid} with respect to a set of constraints
    $\C$ and an instantation $\gamma$ ($\Valid\Phi\C\gamma$) if for all
    $\gamma'$ with $\gamma\leq\gamma'$
    \[\gamma'\Solves\C\implies\gamma'\respects\Phi\]
\end{definition}

\begin{lemma}\label{normaliseFreeLem}
    For all $\gamma:\Sigma$ and $\Phi$ such that $\gamma\respects\Phi$ and $M$,
    $M'$ with $\Normalise{\gamma\Sigma}M{M'}$
    \[\FV{}{M'}\subseteq\FV\Phi M\]
\end{lemma}

\begin{lemma}\label{projRespecLem}
    Given a complete instantiation $\gamma:\Sigma$, for all $\Phi$, $N$, $X$
    such that $\Normalise{\gamma\Sigma}N{N'}$ with $\FV\Phi{N'}\subseteq X$
    \[\gamma\respects\Phi~\wedge~\Indep\Phi{\proj XN}{\Phi'}\implies
    \gamma\respects\Phi'\]
\end{lemma}

\begin{proof}
    By induction on the derivation of $\Indep\Phi{\proj XN}{\Phi'}$.

    {\em Case $N=\Meta n\,\overline M$}. We have $\gamma(\Meta n) =
    \LAM{\overline y}M$ where $M$ is normal. Since $\gamma\respects\Phi$ we get
    $\Meta n\,\overline M\rightarrow \Subst M{\overline y}{\overline x}$, which
    is also normal. We know that the normal form of $\Meta n\,\overline M$
    contains only free variables from $X$, i.e. $\FV{}{\Subst M{\overline
    y}{\overline x}}\subseteq X$ and hence $x_i\notin X\implies
    y_i\notin\FV{}M$. Since $\gamma\respects\Phi$ we can conclude that
    $\gamma\respects\UIndep\Phi ni{x_i\notin X}$.
\end{proof}

\begin{lemma}\label{validLem}
    If $\gamma\Solves\Constr\Sigma\Gamma MNA$ and
    $\Indep\Phi{\Constr\Sigma\Gamma MNA}{\Phi'}$ then
    \[\gamma\respects\Phi \implies \gamma\respects\Phi'\]
\end{lemma}

\begin{proof}
    By induction on the derivation of $\Indep\Phi{\Constr\Sigma\Gamma MNA}{\Phi'}$.
    \\~

    {\em Case}
    \(
    \begin{array}[c]{cc}
    \infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}{\Meta{n}\overline{M}}{N}{A}}
	  {\UIndep{\Phi}{n}{i}{x_i \not\in \FV\Phi N}}}
    {\PhiArgs n{\overline M} = \overline{x} & \Meta{n} \not \in MV(N)}
    \end{array}
    \).

    We have to prove that $\gamma\respects\UIndep\Phi ni{x_i\notin\FV\Phi N}$,
    i.e. that if $\gamma(\Meta n)=\LAM{\overline y}M$ then $x_i\notin\FV\Phi
    N\implies y_i\notin\FV{}M$. Since $\gamma$ solves the constraint we have
    $\EqualCS{\gamma\Sigma}\Gamma{\Meta n\,\overline M}NA$ and thus
    $\Convertible{\gamma\Sigma}{\Meta n\,\overline M}N$. Now
    $\gamma\respects\Phi$ so $\Normalise{\gamma\Sigma}{\Meta n\,\overline
    M}{\Subst M{\overline y}{\overline x}}$ and then also
    $\Normalise{\gamma\Sigma}N{\Subst M{\overline y}{\overline x}}$. If
    $x_i\notin\FV\Phi N$ then by Lemma~\ref{normaliseFreeLem}
    $x_i\notin\FV{}{\Subst M{\overline y}{\overline x}}$ and thus
    $y_i\notin\FV{}M$.
    \\~

    {\em Case}
    \(
    \begin{array}[c]{cc}
    \infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}MNA}{\Phi'}}
    { \Indep{\Phi}{\proj{\FV\Phi M}N}{\Phi'}}
    \end{array}
    \).

    As before we get $\Convertible{\gamma\Sigma}MN$.  Now let $N'$ be the
    common normal form of $M$ and $N$. By Lemma~\ref{normaliseFreeLem} we have
    $\FV{}{N'}\subseteq\FV\Phi{M}$, so we can invoke Lemma~\ref{projRespecLem}
    and conclude $\gamma\respects\Phi'$.
    \\~

    {\em Case}
    \(
    \begin{array}[c]{cc}
    \infer{\Indep{\Phi}{\Constr{\Sigma}{\Gamma}{\Meta{n} \overline{M}}{\Meta{n} \overline{N}}{A}}{\UIndep{\Phi}{n}{i}{x_i \neq y_i}}}
    {\PhiArgs n{\overline{M}} = \overline{x} & \PhiArgs n{\overline{N}} = \overline{y}}
    \end{array}
    \).

    We have to prove that $\gamma\respects\UIndep\Phi ni{x_i\neq y_i}$, i.e.
    that if $\gamma(\Meta n)=\LAM{\overline z}M$ then $x_i\neq y_i \implies
    z_i\notin\FV{}M$. As before $\Convertible{\gamma\Sigma}{\Meta n\,\overline
    M}{\Meta n\,\overline N}$. Since $\gamma\respects\Phi$ we have
    $\Normalise{\gamma\Sigma}{\Meta n\,\overline M}{\Subst M{\overline
    z}{\overline x}}$ and $\Normalise{\gamma\Sigma}{\Meta n\,\overline
    N}{\Subst M{\overline z}{\overline y}}$ and hence ${\Subst M{\overline
    z}{\overline x}} = {\Subst M{\overline z}{\overline y}}$. Thus if $x_i\neq
    y_i$ then $z_i\notin\FV{}M$.
\end{proof}

\begin{theorem}[Uniqueness]\label{uniqThm}
    For all $\Phi$, $\C$, $\gamma$, $\gamma'$ such that $\Valid\Phi\C\gamma$,
    if $\Unify{}\Phi\gamma\C{\gamma'}$ then for any $\sigma\geq\gamma$ such
    that $\sigma\Solves\C$ we have $\sigma=\gamma'$.
\end{theorem}

\begin{proof}
    By induction on the derivation of $\Unify{}\Phi\gamma\C{\gamma'}$.

    {\em Case}
    \(
    \begin{array}[c]{cc}
    \infer{\Unify{}{\Phi}{\gamma}{\{C\} \cup \C}{\gamma'}}
    {\Indep{\Phi}{C}{\Phi'}
     &
     \Unify{}{\Phi'}{\gamma}{\{C\} \cup \C}{\gamma'}
    }
    \end{array}
    \).

    To apply the induction hypothesis we need
    $\Valid{\Phi'}{\{C\}\cup\C}\gamma$. Take $\gamma''$ such that
    $\gamma''\geq\gamma$, $\gamma''\Solves C$. Since
    $\Valid\Phi{\{C\}\cup\C}\gamma$ we get $\gamma''\respects\Phi$, so by
    Lemma~\ref{validLem} $\gamma''\respects\Phi'$, and thus
    $\Valid{\Phi'}{\{C\}\cup\C}\gamma$.
    \\~

    {\em Case}
    \(
    \begin{array}{ccccc}
    \infer{\Unify{}\Phi\gamma{\Constr\Sigma\Gamma{\Meta{n}\,\overline{M}}{N}{A}\cup\C}{\gamma''}}
     { \begin{array}[b]{l}
	    \PhiArgs n{\overline M} = \overline x \\
	    \Meta n\notin MV(N) \\
	    \FV{\Phi}N\subseteq\overline x \\
	    \InScope\Sigma{\Meta n}N
	\end{array}
     &  \gamma' = \SubstUpdate{\gamma}{n}{\LAM{\overline{M}}N}
     &  \Unify{}{\Phi}{\gamma'}{\Simplify{\gamma'}\C}{\gamma''}
     }
    \end{array}
    \).

    Let $\C_0 = \Constr\Sigma\Gamma{\Meta n\,\overline M}NA\cup\C$. We assume $\Valid\Phi{\C_0}\gamma$ and take
    $\sigma\geq\gamma$ such that $\sigma\Solves\C_0$. We want to apply the
    induction hypothesis to $\sigma$. For this we need
    \begin{enumerate}
	\item $\Valid\Phi{\Simplify{\gamma'}\C}{\gamma'}$
	    \begin{proof}
		Take $\gamma_0\geq\gamma'$ such that
		$\gamma_0\Solves\Simplify{\gamma'}\C$.
		$\gamma'\Solves\Constr\Sigma\Gamma{\Meta n\,\overline M}NA$ so
		by Lemma~\ref{leqSolvesLem}
		$\gamma_0\Solves\Constr\Sigma\Gamma{\Meta n\,\overline M}NA$.
		By Lemma~\ref{simplifySolvesLem} $\gamma_0\Solves\C$ and thus
		$\gamma_0\Solves\C_0$.
	    \end{proof}
	\item $\sigma\Solves\Simplify{\gamma'}\C$
	    \begin{proof}
		$\sigma\Solves\C_0$ so $\sigma\Solves\C$ and thus by
		Lemma~\ref{simplifySolvesLem}
		$\sigma\Solves\Simplify{\gamma'}\C$.
	    \end{proof}
	\item $\sigma\geq\gamma'$
	    \begin{proof}
		Let $\sigma(\Meta n)=\LAM{\overline y}M$. Since
		$\sigma\geq\gamma$ all we have to prove is that
		$\Normalise{\sigma\Sigma}{\LAM{\overline M}N}{\LAM{\overline
		y}M}$.  We have $\sigma\Solves\C_0$ so
		$\Convertible{\sigma\Sigma}{\Meta n\,\overline M}N$.  Since
		$\sigma\respects\Phi$, $\Normalise{\sigma\Sigma}{\Meta
		n\,\overline M}{\Subst M{\overline y}{\overline x}}$ and thus
		$\Normalise{\sigma\Sigma}N{\Subst M{\overline y}{\overline
		x}}$. But then $\Normalise{\sigma\Sigma}{\LAM{\overline
		M}N}{\LAM{\overline M}\Subst M{\overline y}{\overline x}} =
		\LAM{\overline y}M$.
	    \end{proof}
    \end{enumerate}

    {\em Case}
    \(\begin{array}[c]{c}
    \infer{\Unify\Sigma\Phi\gamma\varnothing\gamma}{\gamma~\mbox{complete w.r.t. $\Sigma$}}
    \end{array}\).

    Since $\gamma$ is complete, $\sigma\geq\gamma$ implies $\sigma = \gamma$.
\end{proof}

\end{document}

