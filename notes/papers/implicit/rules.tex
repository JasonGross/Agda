
In this section we present the type checking algorithm for {\Core} with meta
variables.

% Describe the problem with meta variables
\subsection{Meta variables in type checking}

A central typing rule in {\Core}, or any dependent type theory, is the
conversion rule, which states that if a term $M$ has type $B$, then $M$ has any
type $A$ convertible to $B$.

\[  \infer{\HasTypeC \Gamma M A}
    { \HasTypeC \Gamma M B
    & \EqualTypeC \Gamma A B
    }
\]

In the absence of meta variables, checking the convertibility of $A$ and $B$ is
straightforward and simply amounts to checking $\beta\eta$-equality. However,
when adding meta variables things get more complicated. Depending of what the
meta variables are used for the conversion checking algorithm is extended in
various ways. If the meta variables are use for interaction, it makes sense to
treat them as black boxes and thus the conversion checker gives up when
encountering a meta variable. If meta variables are used for implicit
syntax--which is what we focus on in this paper--the conversion checker tries
to find instantiations for the meta variables using some form of unification.
In general the unification problems are higher order and hence
undecidable~\cite{huet:unification}\footnote{TODO: correct citation?}.
Consequently the conversion checker will have to give up on some unification
problems. The same is true if meta variables are used for proof search, if a
proof (instantiation of a meta variable) cannot be found the problem might have
to be postponed until more infomation is available. The bottom line is that
the convertibility of $A$ and $B$ might be unknown until some of the meta
variables have been instantiated. If this is the case, the question is what to
do with the conversion rule. Accepting $M : A$ is clearly not correct (see
Section~\ref{secCoerce} for how to break things), but failing is also not the
right thing to do, since later meta variable instantiations might make $A$ and
$B$ convertible.

The solution we present here is to accept the conversion rule, but rather than
concluding that $M : A$ we introduce a fresh constant of type $A$ which
evaluates to $M$ if and only if $A$ and $B$ are convertible. This means, in
effect, that the type checker works with well-typed approximations of terms,
where potentially ill-typed subterms have been replaced by fresh constants.
The subterm corresponding to each constant is recorded, but guarded by the
constraint which would make it well-typed. As soon as the constraint is solved
the constant can freely be replaced by its corresponding subterm. We will refer
to these constants as {\em guarded constants}.

\subsection{Constraints and guarded constants}

Now we present the rules for type checking with meta variables. First we extend
the syntax of signatures to include guarded constants:

\[\begin{array}{lcll}
    C & ::= & \TypeConstr A B \Or \TermConstr M N A \\
    \Sigma & ::= & \ldots \Or
		\Ext \Sigma \ConstDecl p A M \Cs \\
\end{array}\]

We will use lowercase greek letters $\alpha, \beta, \ldots$ for constants
representing meta variables and $p$ and $q$ for guarded constants.

\TODO{..}

\subsection{Operations on the signature}

All rules work on a signature $\Sigma$, containing previously defined
constants, meta variables, and guarded constants.
%
In other words we can write all judgements on the form
\[\ExplicitJudgement \Sigma J {\Sigma'}\]
%
To make the rules easier to read we first define a set of operations reading
and modifying the signature and when presenting the algorithm simply write $J$
for the judgement above. In rules with multiple premisses the signature is
threaded top-down, left-to-right. For instance,
\[\begin{array}{ccc}
{\small\begin{array}[c]{l}
\infer{J}
  {\begin{array}[b]{l}
     P_1
  \\ P_2
  \end{array}
  & P_3
  }
\end{array}}
& ~\mbox{is short-hand for}~
&
{\small\begin{array}[c]{l}
\infer{\ExplicitJudgement {\Sigma_1} J {\Sigma_4}}
  {\begin{array}[b]{l}
     \ExplicitJudgement {\Sigma_1} {P_1} {\Sigma_2}
  \\ \ExplicitJudgement {\Sigma_2} {P_2} {\Sigma_3}
  \end{array}
  & \ExplicitJudgement {\Sigma_3} {P_3} {\Sigma_4}
  }
\end{array}}
\end{array}\]

\begin{figure}
\begin{tabular}{llll}
%    \multicolumn2l{Operations on meta variables} \\
    & $\ExplicitJudgement \Sigma
	{\AddMeta \alpha A}
	{\Ext \Sigma \MetaDecl \alpha A}
    $ & if & $\alpha \notin \Sigma$
    \\
    & $\ExplicitJudgement
	    \Sigma
	    {\InstMeta \alpha M}
	    {\Ext {\Sigma_1} \Ext {\IMetaDecl \alpha A M} \Sigma_2}
    $ & if & $\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\LookupMeta \alpha M}
% 	    \Sigma
%     $ & if & $\IMetaDecl \alpha A M ~\in~ \Sigma$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\Uninstantiated \alpha}
% 	    \Sigma
%     $ & if & $\MetaDecl \alpha A ~\in~ \Sigma$
    \\ {} \\
%    \multicolumn2l{Operations on guarded constants} \\
    & \multicolumn3l{$\ExplicitJudgement
	    \Sigma
	    {\AddConst p A M \Cs}
	    {\Ext \Sigma \ConstDecl p A M \Cs}
    $} \\
    & & if & $p \notin \Sigma$
%     \\
%     & \multicolumn3l{$\ExplicitJudgement
% 	    \Sigma
% 	    {\UpdateGuard p \Cs}
% 	    {\Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} \Sigma_2}
%     $} \\
%     & & if & $\Sigma ~=~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs^\prime} \Sigma_2$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\LookupConst p M}
% 	    \Sigma
%     $ & if & $\ConstDecl p A M \emptyset ~\in~ \Sigma$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\Guarded p}
% 	    \Sigma
%     $ & if & $\ConstDecl p A M \Cs ~\in~ \Sigma$ and $\Cs \neq \emptyset$
    \\ {} \\
%    \multicolumn2l{General operations} \\
    & $\ExplicitJudgement
	    \Sigma
	    {\LookupType c A}
	    \Sigma
    $ & if & $c : A \in \Sigma$
    \\
    & $\ExplicitJudgement
	    \Sigma
	    {\InScope \alpha M}
	    \Sigma
    $ & if & $\begin{array}[t]{ll}
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2 ~~ \mbox{and}
	\\ c \in M ~~ \mbox{implies} ~~ c \in \Sigma_1
%     \\	\IsTypeCS {\Sigma_1} {} A ~~ \mbox{and} ~~ \HasTypeCS \Sigma {} M A ~~ \mbox{implies}
%     \\	\HasTypeCS {\Sigma_1} {} M A
    \end{array}$
    \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\WithSig {\Sigma'} J}
% 	    {\Sigma''}
%     $ & if & $\ExplicitJudgement
% 	    {\Sigma'}
% 	    J
% 	    {\Sigma''}
%     $ \\
\end{tabular}
\caption{Operations on the signature}
\label{figOperations}
\end{figure}

We introduce two operations to manipulate meta variables: $\AddMeta \alpha A$
adds a new meta variable $\alpha$ of type $A$ to the signature, and $\InstMeta
\alpha M$ instantiates $\alpha$ to $M$.

%% Never used
% $\LookupMeta \alpha M$ looks up the
% value of an instantiated meta variable, and $\Uninstantiated \alpha$ verifies
% that $\alpha$ is uninstantiated.

For guarded constants we just add the operation $\AddConst p A M \Cs$ to add a
new guarded constant $p$ of type $A$ and value $M$ guarded by the constraints
$\Cs$. In Section~\ref{secAlgorithm} we explain the rules for solving the
constraints of a guarded constant.

% , $\UpdateGuard p \Cs$ to update the guard of $p$,
% $\LookupConst p M$ to get the value of a guarded constant whose guard has been
% solved, and $\Guarded p$ to verify that the guard of $p$ has not been solved.

We also introduce the following general operations: $\LookupType c A$ looks up
the type $A$ of a constant $c$, and $\InScope \alpha M$ checks that $M$ is in
scope at the definition site of $\alpha$ (to ensure that $\alpha$ can be
instantiated to $M$).

%, and $\WithSig \Sigma J$ which checks $J$ in the signature $\Sigma$.

Detailed definitions of the operations can be found in
Figure~\ref{figOperations}.

\subsection{The algorithm} \label{secAlgorithm}

Next we present the type checking algorithm.  We use a bidirectional algorithm,
consisting of the following main judgement forms.

\[\begin{array}{ll}
    \IsType e A & \mbox{well-formed types} \\
    \CheckType e A M & \mbox{type checking} \\
    \InferType e A M & \mbox{type inference} \\
    \EqualType A B \Cs & \mbox{type conversion} \\
    \Equal M N A \Cs & \mbox{term conversion} \\
\end{array}\]

The rules for well-formed types and type checking and inference takes an
expression in the user syntax produces a type or term in {\Core} which is a
well-formed approximation of the user expression. Conversion checking produces
a set of unsolved constraints which needs to be solved for the judgement to be
true in {\Core}. The exact form of type checking algorithm used is not very
important--a unidirectional algorithm would also work. What is important is
that computation is performed on the well-typed approximations rather than the
user expressions.

We use typed conversion for two reasons: it is a nice way to implement
$\eta$-equality, and perhaps more importantly to prove the correctness of the
algorithm we need the invariant that when checking $\Equal M N A \Cs$ we have
$\HasTypeC \Gamma M A$ and $\HasTypeC \Gamma N A$. The type is only
computationally relevant for checking $\eta$-equality.

When checking conversion we also need the following judgement forms.

\[\begin{array}{ll}
    \EqualWhnf M N A \Cs & \mbox{conversion of weak head normal forms} \\
    \Equal {\bar M} {\bar N} \Delta \Cs & \mbox{conversion of sequences of terms} \\
\end{array}\]

In the following we let $J$ range over judgements of these seven forms. To save
some space we omit the rules for checking well-formed types and most of the
rules for type checking and inference. The rules are simple extensions of the
standard type checking algorithm\footnote{\TODO{cite core paper}} to produce
well-typed terms. The interesting type checking rules are those for type
checking meta variables and the conversion rules.

\URules{

\infer{ \CheckType {?} A {\alpha \, \Gamma }}
{\begin{array}{l}
    \AddMeta \alpha {\Gamma \to A}
\end{array}}

\quad

\infer{
    \CheckType e A M
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \emptyset
\end{array}}

\quad

\infer{
    \CheckType e A {p\,\Gamma}
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A} {\LAM \Gamma M} \Cs
\end{array}}

}

When type checking a user meta variable we add a fresh meta variable to the
signature and return this. Since meta variables are part of the signature they
have to be lifted to the top-level\footnote{\TODO{cite something here?}}.

We have two versions of the conversion rule. The first corresponds to the
normal conversion rule and applies when no constraints are left over. The
interesting case is when we cannot safely conclude that $A = B$, in which case
we introduce a fresh guarded constant. As for meta variables, guarded constants
are lifted to the top-level.

When checking conversion of two function types, an interesting question is what
to do when comparing the domains gives rise to constraints. The rule in question is

\URules{
% (x : A) -> B = (x : A') -> B'
\infer{
    \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} {\Cs \cup \Cs^\prime}
}{\begin{array}{l}
    \EqualType {A_1} {A_2} \Cs, ~~ \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A_1 \to A_2} {\LAM {\Gamma\,x} x} \Cs
\\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {\SubstD {B_2} {p ~ \Gamma \, x}} {\Cs^\prime}
\end{array}}
}

To ensure the correctness of the algorithm we need to maintain the invariant
that when we check $\EqualType A B \Cs$ we have $\IsTypeC \Gamma A$ and
$\IsTypeC \Gamma B$. Thus if we do not know whether $A_1 = A_2$ it is not
correct to check $\EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {B_2} {\Cs^\prime}$
since $B_2$ is not well-formed in $\Ext \Gamma x : A_1$. To solve the problem
we substitute a guarded constant for $x$ in $B_2$.

% \quad
% 
% \infer{
%     \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} \Cs
% }{\begin{array}{l}
%     \EqualType {A_1} {A_2} \emptyset
% \\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {B_2} \Cs
% \end{array}}
% 
%  \\{}\\
% 
% % El M = El N
% 
% \infer{
%     \EqualType {\EL M} {\EL N} \Cs
% }{\begin{array}{l}
%     \Equal M N \SET \Cs
% \end{array}}
% 
% \end{array}\]}

Checking conversion of terms is done on weak head normal forms. The only rule
that is applied before weak head normalisation is the $\eta$-rule.

\URules{

% Eta

\infer{
    \Equal M N {\PI x A B} \Cs
}{
    \EqualCtx {\Ext \Gamma x : A} {M \, x} {N \, x} B \Cs
}

\qquad

% Weak head normalisation

\infer{
    \Equal M N A \Cs
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \EqualWhnf {M'} {N'} A \Cs
\end{array}
}

}

We use the reduction of {\Core} when reducing to weak head normal forms. This
is made precise later in this section, but essentially instantiated meta are
unfolded and guarded constants are unfolded if the guard is empty.

\Rules{Weak head conversion}{

% Variable head

\infer{
    \EqualWhnf {x ~ \bar M} {x ~ \bar N} A \Cs
}{\begin{array}{l}
    x : \Delta \to B \in \Gamma
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\qquad

% Constant head

\infer{
    \EqualWhnf {h ~ \bar M} {h ~ \bar N} A \Cs
}{\begin{array}{l}
    \LookupType h {\Delta \to B}
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\\{}\\

% Instantiation

\infer{
    \EqualWhnf {\alpha ~ \bar x} M A \emptyset
}{
\begin{array}[b]{l}
    \bar x~\mathit{distinct}
\\  \Normalise M {M'}
\\  \FV {M'} \subseteq \bar x
\\  \alpha \notin M'
\end{array}
& \begin{array}[b]{l}
    \InScope \alpha {\LAM {\bar x} M'}
\\  \InstMeta \alpha {\LAM {\bar x} M'}
\end{array}
}

\qquad

\begin{array}{l}
\mathit{[symmetric~rule]}\\
{}\\
\end{array}

\\{}\\

\infer{
    \EqualWhnf {p ~ \bar M} N A {\left\{\TermConstr {p ~ \bar M} N A\right\}}
}{}

}

\Rules{Term sequence conversion}{

% No constraints

\infer{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \Cs
}{\begin{array}{l}
    \Equal M N A \emptyset
\\  \Equal {\bar M} {\bar N} {\SubstD \Delta M} \Cs
\end{array}}

\\{}\\

% Some constraints

\infer{
    \begin{array}{l}
        \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {~~} \\
	\hfill \left\{ \TermConstr {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \right\}
    \end{array}
}{\begin{array}{ll}
    \Equal M N A \Cs \neq \emptyset
&   x \in \FV \Delta
\end{array}}

\\{}\\

\infer{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {\Cs_1 \cup \Cs_2}
}{\begin{array}{ll}
    x \notin \FV \Delta
\\  \Equal M N A {\Cs_1} \neq \emptyset
\\  \Equal {\bar M} {\bar N} \Delta {\Cs_2}
\end{array}}

}

\begin{definition}
    Given a signature $\Sigma$ containing meta variables and guarded constants
    we can recover a signature in the underlying logic $\CoreSig \Sigma$ by
    replacing guarded constants with normal constants, retaining the definition
    if the guard is empty and removing it otherwise.

    Formally:
    \[\begin{array}{lclcl}
	\CoreSig{\Ext \Sigma \ConstDecl p A M \emptyset}
	    & = & \Ext {\CoreSig \Sigma} {\IMetaDecl p A M} \\
	\CoreSig{\Ext \Sigma \ConstDecl p A M \Cs}
	    & = & \Ext {\CoreSig \Sigma} {\MetaDecl p A} && \mathrm{if} ~ \Cs \neq \emptyset \\
	\CoreSig{\Ext \Sigma \IMetaDecl f A M}
	    & = & \Ext {\CoreSig \Sigma} {\IMetaDecl f A M} \\
	\CoreSig{\Ext \Sigma \MetaDecl c A}
	    & = & \Ext {\CoreSig \Sigma} {\MetaDecl c A} \\
    \end{array}\]
\end{definition}

We will simply write $\Sigma$ for $\CoreSig \Sigma$ when it is clear from
the context that the latter is intended. For instance, we write $\HasTypeCS
\Sigma \Gamma M A$ rather than $\HasTypeCS {\CoreSig \Sigma} \Gamma M A$.

\subsubsection{Weak head normalisation}

We use the weak head normalisation from the underlying logic:
\[
    \infer{
	\ExplicitJudgement \Sigma {\whnf M N} \Sigma
    }{
	\vdash_{\CoreSig \Sigma} \whnf M N
    }
\]

\subsubsection{Constraint Solving}

So far, we have not looked at when or how the guards of a constant are
simplified or solved. In principle this can be done at any time, for instance
as a separate phase after type checking. In practise, however, it might be a
better idea to interleave constraint solving and type checking.

Constraint simplification amounts to retrying the guards of a constant. The
notation $\CheckConstr \Cs {\Cs^\prime}$ means checking each of the constraints in
$\Cs$ and taking $\Cs^\prime$ to be the union of the results.

% Constraint solving
\Rules{Constraint solving}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    \Simplify
	    {\Ext {\Sigma^\prime_1} \Ext {\ConstDecl p A M {\Cs^\prime}} \Sigma_2}
    }{\begin{array}{ll}
	\multicolumn2l{\Sigma ~ = ~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} {\Sigma_2}} \\
	\ExplicitJudgement {\Sigma_1} {\CheckConstr \Cs {\Cs^\prime}} {\Sigma^\prime_1} 
	& \Cs \neq {\Cs^\prime} \\
    \end{array}
    }
}

% Not used
% \begin{definition}[Normal signature]
%     A signature $\Sigma$ is in {\em normal form} if it is not the case that
%     $\ExplicitJudgement \Sigma \Simplify {\Sigma^\prime}$ for some $\Sigma^\prime$.
% \end{definition}

\subsection{Adding pattern matching} \label{secAddPatternMatching}

Some notes on how to add pattern matching.

% Blocked terms
\Rules{Check if evaluation of a term is blocked by a meta variable}{
    \infer{
	\Blocked {f \, \bar M}
    }{\begin{array}{l}
	f ~ \mathit{pattern ~ matches ~ on ~ its ~ ith ~ argument}
    \\	M_i = \alpha \, \bar N ~~ or ~~ \Blocked {M_i}
    \end{array}}

\qquad

\infer{
    \Equal M N A {\left\{ \TermConstr {M'} {N'} A \right\}}
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \Blocked {M'} ~ \mathit{or} ~ \Blocked {N'}
\end{array}
}

}

