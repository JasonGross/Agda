
The basic idea is to introduce new constants for potentially ill-typed terms.  
The values of these constants will be guarded by a set of constraints and can
only be inspected if the set is empty.

Now we present the rules for type checking with meta variables. First we extend
the syntax of signatures to include guarded constants:

\[\begin{array}{lcll}
    C & ::= & \EqualTypeCS \Sigma \Gamma A B \Or
	      \EqualCS \Sigma \Gamma M N A \\
    \Sigma & ::= & \ldots \Or
		\Ext \Sigma \ConstDecl p A M \Cs \\
\end{array}\]

We will use lowercase greek letters $\alpha, \beta, \ldots$ for constants
representing meta variables and $p$ and $q$ for guarded constants.

\subsection{Monadic Rules}

All rules work on a signature $\Sigma$, containing previously defined
constants, meta variables, and guarded constants.
%
In other words we can write all judgements on the form
\[\ExplicitJudgement \Sigma J {\Sigma'}\]
%
To make the rules easier to read we use a monadic presentation and simply write
$J$ for the judgement above.
%
To manipulate the meta variables and guarded constants we introduce some extra
judgements with the following rules:

% Adding metas
\Rules{Add meta variable}{

\infer{
    \ExplicitJudgement
	\Sigma
	{\AddMeta \alpha A}
	{\Ext \Sigma \MetaDecl \alpha A}
}{ \alpha \notin \Sigma }
}

% Instantiating metas
\Rules{Instantiate meta variable}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\InstMeta \alpha M}
	    {\Ext {\Sigma_1} \Ext {\IMetaDecl \alpha A M} \Sigma_2}
    }{ \Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2
    }
}

% Lookup metas
\Rules{Lookup meta variable}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupMeta \alpha M}
	    \Sigma
    }{
	\IMetaDecl \alpha A M ~\in~ \Sigma
    }

\qquad

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\Uninstantiated \alpha}
	    \Sigma
    }{
	\MetaDecl \alpha A ~\in~ \Sigma
    }

}

% Add constant
\Rules{Add guarded constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\AddConst p A M \Cs}
	    {\Ext \Sigma \ConstDecl p A M \Cs}
    }{ p \notin \Sigma }
}

% Update guard
\Rules{Update the guard of a constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\UpdateGuard p \Cs}
	    {\Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} \Sigma_2}
    }{
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs^\prime} \Sigma_2
    }

}

% Lookup guarded constant
\Rules{Lookup the definition of a guarded constant}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupConst p M}
	    \Sigma
    }{
	\ConstDecl p A M \emptyset ~\in~ \Sigma
    }

\qquad

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\Guarded p}
	    \Sigma
    }{
	\ConstDecl p A M \Cs ~\in~ \Sigma
    &	\Cs \neq \emptyset
    }
}

% Lookup the type of a normal constant
\Rules{Lookup the type of a constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupType c A}
	    \Sigma
    }{
	c : A \in \Sigma
    }

}

% % Definition of normal constant
% \Rules{Lookup the definition of a normal constant}{
% 
%     \infer{
% 	\ExplicitJudgement
% 	    \Sigma \Phi \Xi
% 	    {\LookupClause f {\vec p} M}
% 	    \Phi \Xi
%     }{
% 	f~\vec p = M ~\in~ \Sigma
%     }
% }

% Check that a term is well-scoped
\Rules{Check that a term is well-scoped relative to a meta variable}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\InScope \alpha M}
	    \Sigma
    }{\begin{array}{ll}
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2
    \\	\forall h \in M. ~ h \in \Sigma_1
    \\	\forall \beta \in M.~
	    \Sigma ~=~ \Ext {\Sigma^\prime_1} \Ext {\MetaDecl \beta A} {\Sigma^\prime_2}
		& \implies
	    \Sigma^\prime_1 \leq \Sigma_1
    \\	\forall \beta \in M.~
	    \Sigma ~=~ \Ext {\Sigma^\prime_1} \Ext {\IMetaDecl \beta A M} {\Sigma^\prime_2}
		& \implies
	    \InScope \alpha M
    \\	\forall p \in M.~
	    \Sigma ~=~ \Ext {\Sigma^\prime_1} \Ext {\ConstDecl p A M \Cs} {\Sigma^\prime_2}
		& \implies
	    \InScope \alpha M
    \end{array}
    }
}

% Change the signature
\Rules{Check a judgement in a different signature}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\WithSig {\Sigma'} J}
	    {\Sigma''}
    }{
	\ExplicitJudgement
	    {\Sigma'}
	    J
	    {\Sigma''}
    }

}

% Blocked terms
\Rules{Check if evaluation of a term is blocked by a meta variable}{
    \infer{
	\Blocked {f \, \bar M}
    }{\begin{array}{l}
	f ~ \mathit{pattern ~ matches ~ on ~ its ~ ith ~ argument}
    \\	M_i = \alpha \, \bar N ~~ or ~~ \Blocked {M_i}
    \end{array}}
}

\subsection{The actual rules}

We have the following main judgement forms.

\[\begin{array}{ll}
    \IsType e A & \mbox{well-formed types} \\
    \CheckType e A M & \mbox{type checking} \\
    \InferType e A M & \mbox{type inference} \\
    \EqualType A B \Cs & \mbox{type convertibility} \\
    \Equal M N A \Cs & \mbox{term convertibility} \\
\end{array}\]

We also need some helper judgement forms.

\[\begin{array}{ll}
    \EqualWhnf M N A \Cs & \mbox{convertibility of weak head normal forms} \\
    \Equal {\bar M} {\bar N} \Delta \Cs & \mbox{convertibility of sequences of terms} \\
\end{array}\]

Now the rules are

\TODO{explain notation $p\,\Gamma$ and $\LAM \Gamma M$ (not here)}

\Rules{Conversion rule}{

% Conversion rule

\infer{
    \CheckType a A M
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \emptyset
\end{array}}

\qquad

\infer{
    \CheckType e A {p\,\Gamma}
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A} {\LAM \Gamma M} \Cs
\end{array}}

}

\Rules{Type checking meta variables}{

\infer{ \CheckType {?} A {\alpha \, \Gamma }}
{\begin{array}{l}
    \AddMeta \alpha {\Gamma \to A}
\end{array}}

}

\Rules{Type convertibility}{

% (x : A) -> B = (x : A') -> B'

\infer{
    \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} {\Cs \cup \Cs^\prime}
}{\begin{array}{l}
    \EqualType {A_1} {A_2} \Cs, ~~ \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A_1 \to A_2} {\LAM {\Gamma\,x} x} \Cs
\\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {\SubstD {B_2} {p ~ \Gamma \, x}} {\Cs^\prime}
\end{array}}

\\{}\\

\infer{
    \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} \Cs
}{\begin{array}{l}
    \EqualType {A_1} {A_2} \emptyset
\\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {B_2} \Cs
\end{array}}

\qquad

% El M = El N

\infer{
    \EqualType {\EL M} {\EL N} \Cs
}{\begin{array}{l}
    \Equal M N \SET \Cs
\end{array}}

}

\Rules{Term convertibility}{

% Eta

\infer{
    \Equal M N {\PI x A B} \Cs
}{
    \EqualCtx {\Ext \Gamma x : A} {M \, x} {N \, x} B \Cs
}

\\{}\\

% Weak head normalisation

\infer{
    \Equal M N A \Cs
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \mathit{not} ~ \Blocked {M'}
\\  \mathit{not} ~ \Blocked {N'}
\\  \EqualWhnf {M'} {N'} A \Cs
\end{array}
}

\qquad

\infer{
    \Equal M N A {\left\{ \EqualC \Gamma M N A \right\}}
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \Blocked {M'} ~ \mathit{or} ~ \Blocked {N'}
\end{array}
}

}

\Rules{Weak head convertibility}{

% Variable head

\infer{
    \EqualWhnf {x ~ \bar M} {x ~ \bar N} A \Cs
}{\begin{array}{l}
    x : \Delta \to B \in \Gamma
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\qquad

% Constant head

\infer{
    \EqualWhnf {h ~ \bar M} {h ~ \bar N} A \Cs
}{\begin{array}{l}
    \LookupType h {\Delta \to B}
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\\{}\\

% Instantiation

\infer{
    \EqualWhnf {\alpha ~ \bar x} M A \emptyset
}{
\begin{array}[b]{l}
    \bar x~\mathit{distinct}
\\  \FV M \subseteq \bar x
\\  \alpha \notin M
\\  \InScope \alpha M
\end{array}
& \InstMeta \alpha {\LAM {\bar x} M}
}

\qquad

\begin{array}{l}
\mathit{[symmetric~rule]}\\
{}\\
\end{array}

\\{}\\

\infer{
    \EqualWhnf {p ~ \bar M} N A {\left\{\EqualC \Gamma {p ~ \bar M} N A\right\}}
}{}

}

\Rules{Term sequence convertibility}{

% No constraints

\infer{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \Cs
}{\begin{array}{l}
    \Equal M N A \emptyset
\\  \Equal {\bar M} {\bar N} {\SubstD \Delta M} \Cs
\end{array}}

\\{}\\

% Some constraints

\infer{
    \begin{array}{l}
        \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {~~} \\
	\hfill \left\{ \EqualC \Gamma {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \right\}
    \end{array}
}{\begin{array}{ll}
    \Equal M N A \Cs \neq \emptyset
&   x \in \FV \Delta
\end{array}}

\\{}\\

\infer{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {\Cs_1 \cup \Cs_2}
}{\begin{array}{ll}
    x \notin \FV \Delta
\\  \Equal M N A {\Cs_1} \neq \emptyset
\\  \Equal {\bar M} {\bar N} \Delta {\Cs_2}
\end{array}}

}

\begin{definition}
    Given a signature $\Sigma$ containing meta variables and guarded constants
    we can recover a signature in the underlying logic $\CoreSig \Sigma$ by
    replacing guarded constants with normal constants, retaining the definition
    if the guard is empty and removing it otherwise.

    Formally:
    \[\begin{array}{lclcl}
	\CoreSig{\Ext \Sigma \ConstDecl p A M \emptyset}
	    & = & \Ext {\CoreSig \Sigma} {\IMetaDecl p A M} \\
	\CoreSig{\Ext \Sigma \ConstDecl p A M \Cs}
	    & = & \Ext {\CoreSig \Sigma} {\MetaDecl p A} && \mathrm{if} ~ \Cs \neq \emptyset \\
	\CoreSig{\Ext \Sigma \IMetaDecl f A M}
	    & = & \Ext {\CoreSig \Sigma} {\IMetaDecl f A M} \\
	\CoreSig{\Ext \Sigma \MetaDecl c A}
	    & = & \Ext {\CoreSig \Sigma} {\MetaDecl c A} \\
    \end{array}\]
\end{definition}

We will simply write $\Sigma$ for $\CoreSig \Sigma$ when it is clear from
the context that the latter is intended. For instance, we write $\HasTypeCS
\Sigma \Gamma M A$ rather than $\HasTypeCS {\CoreSig \Sigma} \Gamma M A$.

\subsubsection{Weak head normalisation}

We use the weak head normalisation from the underlying logic:
\[
    \infer{
	\ExplicitJudgement \Sigma {\whnf M N} \Sigma
    }{
	\CoreSig \Sigma \vdash \whnf M N
    }
\]

\subsubsection{Constraint Solving}

So far, we have not looked at when or how the guards of a constant are
simplified or solved. In principle this can be done at any time, for instance
as a separate phase after type checking, but in practise it might be a better idea
to interleave constraint solving and type checking.

Constraint simplification amounts to retrying the guards of a constant. The
notation $\CheckConstr \Cs {\Cs^\prime}$ means checking each of the constraints in
$\Cs$ and taking $\Cs^\prime$ to be the union of the results.

% Constraint solving
\Rules{Constraint solving}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    \Simplify
	    {\Ext {\Sigma^\prime_1} \Ext {\ConstDecl p A M {\Cs^\prime}} \Sigma_2}
    }{\begin{array}{ll}
	\multicolumn2l{\Sigma ~ = ~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} {\Sigma_2}} \\
	\ExplicitJudgement {\Sigma_1} {\CheckConstr \Cs {\Cs^\prime}} {\Sigma^\prime_1} 
	& \Cs \neq {\Cs^\prime} \\
    \end{array}
    }
}

\begin{definition}[Normal signature]
    A signature $\Sigma$ is in {\em normal form} if it is not the case that
    $\ExplicitJudgement \Sigma \Simplify {\Sigma^\prime}$ for some $\Sigma^\prime$.
\end{definition}

