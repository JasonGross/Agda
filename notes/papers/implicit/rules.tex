
The basic idea is to introduce new constants for potentially ill-typed terms.  
The values of these constants will be guarded by a set of constraints and can
only be inspected if the set is empty.

Now we present the rules for type checking with meta variables. First we extend
the syntax:

\[\begin{array}{lcll}
    M & ::= & \ldots \Or \alpha \Or p \\
    C & ::= & \EqualTypeCS \Sigma \Gamma A B \Or
	      \EqualCS \Sigma \Gamma M N A \\
    \Phi & ::= & \bullet \Or
		 \Ext \Phi \MetaDecl \alpha A \Or
		 \Ext \Phi \IMetaDecl \alpha A M \\
    \Xi  & ::= & \bullet \Or \Ext \Xi \ConstDecl p A M \Cs \\
\end{array}\]

We will use lowercase greek letters $\alpha, \beta, \ldots$ for meta variables
and $p, q, \ldots$ for guarded constants.

\subsection{Monadic Rules}

All rules work on a signature $\Sigma$, containing previously defined
constants, meta variables, and guarded constants.
%
In other words we can write all judgements on the form
\[\ExplicitJudgement \Sigma J {\Sigma'}\]
%
To make the rules easier to read we use a monadic
presentation~\cite{monadicRules} and simply write $J$ for the judgement above.
%
To manipulate the meta variables and guarded constants we introduce some extra
judgements with the following rules:

% Adding metas
\Rules{Add meta variable}{

\infer{
    \ExplicitJudgement
	\Sigma
	{\AddMeta \alpha A}
	{\Ext \Sigma \MetaDecl \alpha A}
}{ \alpha \notin \Sigma }
}

% Instantiating metas
\Rules{Instantiate meta variable}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\InstMeta \alpha M}
	    {\Ext {\Sigma_1} \Ext {\IMetaDecl \alpha A M} \Sigma_2}
    }{ \Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2
    }
}

% Lookup metas
\Rules{Lookup meta variable}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupMeta \alpha M}
	    \Sigma
    }{
	\IMetaDecl \alpha A M ~\in~ \Sigma
    }

\\{}\\

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\Uninstantiated \alpha}
	    \Sigma
    }{
	\MetaDecl \alpha A ~\in~ \Sigma
    }

}

% Add constant
\Rules{Add guarded constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\AddConst p A M \Cs}
	    {\Ext \Sigma \ConstDecl p A M \Cs}
    }{ p \notin \Sigma }
}

% Update guard
\Rules{Update the guard of a constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\UpdateGuard p \Cs}
	    {\Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} \Sigma_2}
    }{
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs^\prime} \Sigma_2
    }

}

% Lookup guarded constant
\Rules{Lookup the definition of a guarded constant}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupConst p M}
	    \Sigma
    }{
	\ConstDecl p A M \emptyset ~\in~ \Sigma
    }

\\{}\\

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\Guarded p}
	    \Sigma
    }{
	\ConstDecl p A M \Cs ~\in~ \Sigma
    &	\Cs \neq \emptyset
    }
}

% Lookup the type of a normal constant
\Rules{Lookup the type of a constant}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\LookupType c A}
	    \Sigma
    }{
	c : A \in \Sigma
    }

}

% % Definition of normal constant
% \Rules{Lookup the definition of a normal constant}{
% 
%     \infer{
% 	\ExplicitJudgement
% 	    \Sigma \Phi \Xi
% 	    {\LookupClause f {\vec p} M}
% 	    \Phi \Xi
%     }{
% 	f~\vec p = M ~\in~ \Sigma
%     }
% }

% Check that a term is well-scoped
\Rules{Check that a term is well-scoped relative to a meta variable}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\InScope \alpha M}
	    \Phi \Xi
    }{\begin{array}{ll}
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2
    &	\forall c \in M.~c \in \Sigma_1
    \end{array}
    }
}
\TODO{sloppy}

% Change the signature
\Rules{Check a judgement in a different signature}{

    \infer{
	\ExplicitJudgement
	    \Sigma
	    {\WithSig {\Sigma'} J}
	    {\Sigma''}
    }{
	\ExplicitJudgement
	    {\Sigma'}
	    J
	    {\Sigma''}
    }

}

% Constraint solving
\Rules{Simplify guards}{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    \SolveConstraints
	    {\Sigma'}
    }{\begin{array}{l}
	\mathit{for~each} ~ p_i ~ \mathit{such~that}~
	    \Sigma ~ = ~ \Ext {\Sigma_i} \Ext {\ConstDecl {p_i} {A_i} {M_i} {\Cs_i}} {\Sigma^\prime_i} \\
	\quad\WithSig {\Sigma_i} \Cs_i \leadsto {\Cs^\prime_i} \\
	\quad\UpdateGuard {p_i} {\Cs^\prime_i}
    \end{array}
    }
}

% Blocked terms
\Rules{Check if evaluation of a term is blocked by a meta variable}{
    \infer{
	\Blocked {f \, \bar M}
    }{\begin{array}{l}
	f ~ \mathit{pattern ~ matches ~ on ~ its ~ ith ~ argument}
    \\	M_i = \alpha \, \bar N ~~ or ~~ \Blocked {M_i}
    \end{array}}
}

\TODO{Where does $\Sigma'$ come from? How do we know when to stop?}

\subsection{The actual rules}

We have the following main judgement forms.

\[\begin{array}{ll}
    \CheckType e A M & \mbox{type checking} \\
    \InferType e A M & \mbox{type inference} \\
    \EqualType A B \Cs & \mbox{type convertibility} \\
    \Equal M N A \Cs & \mbox{term convertibility} \\
\end{array}\]

We also need some helper judgement forms.

\[\begin{array}{ll}
    \EqualWhnf M N A \Cs & \mbox{convertibility of weak head normal forms} \\
    \Equal {\bar M} {\bar N} \Delta \Cs & \mbox{convertibility of sequences of terms} \\
\end{array}\]

Now the rules are

\TODO{explain notation $p\,\Gamma$ and $\LAM \Gamma M$ (not here)}

\Rules{Conversion rule}{

% Conversion rule

\infer{
    \CheckType a A M
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \emptyset
\end{array}}

\qquad

\infer{
    \CheckType e A {p\,\Gamma}
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A} {\LAM \Gamma M} \Cs
\end{array}}

}

\Rules{Type convertibility}{

% (x : A) -> B = (x : A') -> B'

\infer{
    \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} \Cs
}{\begin{array}{l}
    \EqualType {A_1} {A_2} \Cs
\\  \AddConst p {\Gamma \to A_1 \to A_2} {\LAM {\Gamma\,x} x} \Cs
\\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {\SubstD {B_2} {p ~ \Gamma \, x}} \Cs
\end{array}}

\\{}\\

% El M = El N

\infer{
    \EqualType {\EL M} {\EL N} \Cs
}{\begin{array}{l}
    \Equal M N \SET \Cs
\end{array}}

}

\Rules{Term convertibility}{

% Eta

\infer{
    \Equal M N {\PI x A B} \Cs
}{
    \EqualCtx {\Ext \Gamma x : A} {M~x} {N~x} B \Cs
}

\\{}\\

% Weak head normalisation

\infer{
    \Equal M N A \Cs
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \mathit{not} ~ \Blocked {M'}
\\  \mathit{not} ~ \Blocked {N'}
\\  \EqualWhnf {M'} {N'} A \Cs
\end{array}
}

\qquad

\infer{
    \Equal M N A {\left\{ \EqualC \Gamma M N A \right\}}
}{\begin{array}[b]{l}
    \whnf M {M'}
\\  \whnf N {N'}
\\  \Blocked {M'} ~ \mathit{or} ~ \Blocked {N'}
\end{array}
}

}

\Rules{Weak head convertibility}{

% Variable head

\infer{
    \EqualWhnf {x ~ \bar M} {x ~ \bar N} A \Cs
}{\begin{array}{l}
    x : \Delta \to B \in \Gamma
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\qquad

% Constant head

\infer{
    \EqualWhnf {c ~ \bar M} {c ~ \bar N} A \Cs
}{\begin{array}{l}
    \LookupType h {\Delta \to B}
\\  \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}
}

\\{}\\

% Instantiation

\infer{
    \EqualWhnf {\alpha ~ \bar x} M A \emptyset
}{
\begin{array}[b]{l}
    \bar x~\mathit{distinct}
\\  \FV M \subseteq \bar x
\\  \alpha \notin M
\\  \InScope \alpha M
\end{array}
& \InstMeta \alpha {\LAM {\bar x} M}
}

\qquad

\begin{array}{l}
\mathit{[symmetric~rule]}\\
{}\\
\end{array}

\\{}\\

\infer{
    \EqualWhnf {p ~ \bar M} N A {\left\{\EqualC \Gamma {p ~ \bar M} N A\right\}}
}{}

}

\Rules{Term sequence convertibility}{

% No constraints

\infer{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \Cs
}{\begin{array}{l}
    \Equal M N A \emptyset
\\  \Equal {\bar M} {\bar N} {\SubstD \Delta M} \Cs
\end{array}}

\\{}\\

% Some constraints

\infer{
    \begin{array}{l}
        \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {~~} \\
	\hfill \left\{ \EqualC \Gamma {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \right\}
    \end{array}
}{\begin{array}{l}
    \Equal M N A \Cs \neq \emptyset
\end{array}}

}

\TODO{When do we solve constraints: at the end.}

% \Rules{Weak head normalisatiton}{
% 
% \infer{
%     \whnf {f \, \vec N} {M'}
% }{\begin{array}{l}
%     \whnf {\vec N} {\AppSub \gamma {\vec p}}
% \\  \LookupClause f {\vec p} M
% \\  \whnf {\AppSub \gamma M} {M'}
% \end{array}}
% 
% \qquad
% 
% \infer{
%     \whnf {\alpha} {M'}
% }{\begin{array}{l}
%     \LookupMeta \alpha M
% \\  \whnf M {M'}
% \end{array}}
% 
% \qquad
% 
% \infer{
%     \whnf {p} {M'}
% }{\begin{array}{l}
%     \LookupConst p M
% \\  \whnf M {M'}
% \end{array}}
% 
% \\{}\\
% 
% \infer{
%     \whnf {(\LAM x M)\,N} {M'}
% }{
%     \whnf {\Subst M x N} {M'}
% }
% 
% \qquad
% 
% \infer{
%     \whnf {M\,N} {M'\,N}
% }{
%     \whnf M {M'}
% }
% 
% \\{}\\
% 
% \infer{ \whnf x x }{}
% 
% \qquad
% 
% \infer{ \whnf c c }{}
% 
% \qquad
% 
% \infer{ \whnf \alpha \alpha }{
%     \Uninstantiated \alpha
% }
% 
% \qquad
% 
% \infer{ \whnf p p }{
%     \Guarded p
% }
% 
% }

\begin{definition}
    Given a signature $\Sigma$ containing meta variables and guarded constants
    we can recover a signature in the underlying logic $\CoreSig \Sigma$ by
    replacing guarded constants with normal constants, retaining the definition
    if the guard is empty and removing it otherwise.
\end{definition}

\subsubsection{Weak head normalisation}

We use the weak head normalisation from the underlying logic:
\[
    \infer{
	\ExplicitJudgement \Sigma {\whnf M N} \Sigma
    }{
	\CoreSig \Sigma \vdash \whnf M N
    }
\]

\TODO{
How to distinguish blocked terms from other terms ($f\,\alpha$ vs $f\,x$)?

Needs to be done separately from normalisation. Everything should weak head
normalise.
}

