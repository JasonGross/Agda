
In this section we present the type checking algorithm for {\Core} with meta-variables.

% Describe the problem with meta-variables
\subsection{Meta variables in type checking}

A central typing rule in {\Core}, or any dependent type theory, is the
conversion rule, which states that if a term $M$ has type $B$, then $M$ has any
type $A$ convertible to $B$.

\[  \infer{\HasTypeC \Gamma M A}
    { \HasTypeC \Gamma M B
    & \EqualTypeC \Gamma A B
    }
\]

In the absence of meta-variables, checking the convertibility of $A$ and $B$ is
straightforward and simply amounts to checking $\beta\eta$-equality. However,
when adding meta-variables things get more complicated. Depending of what the
meta-variables are used for the conversion checking algorithm is extended in
various ways. If the meta-variables are use for interaction, it makes sense to
treat them as black boxes and thus the conversion checker gives up when
encountering a meta-variable. If meta-variables are used for implicit
syntax--which is what we focus on in this paper--the conversion checker tries
to find instantiations for the meta-variables using some form of unification.
In general the unification problems are higher order and hence
undecidable~\cite{huet:unification}\TODO{correct citation?}.
Consequently the conversion checker will have to give up on some unification
problems. The same is true if meta-variables are used for proof search, if a
proof (instantiation of a meta-variable) cannot be found the problem might have
to be postponed until more infomation is available. The bottom line is that
the convertibility of $A$ and $B$ might be unknown until some of the meta-variables have been instantiated. If this is the case, the question is what to
do with the conversion rule. Accepting $M : A$ is clearly not correct (see
Section~\ref{secCoerce} for how to break things), but failing is also not the
right thing to do, since later meta-variable instantiations might make $A$ and
$B$ convertible.

The solution we present here is to accept the conversion rule, but rather than
concluding that $M : A$ we introduce a fresh constant of type $A$ which
evaluates to $M$ if and only if $A$ and $B$ are convertible. This means, in
effect, that the type checker works with well-typed approximations of terms,
where potentially ill-typed subterms have been replaced by fresh constants.
The subterm corresponding to each constant is recorded, but guarded by the
constraint which would make it well-typed. As soon as the constraint is solved
the constant can freely be replaced by its corresponding subterm. We will refer
to these constants as {\em guarded constants}.

\subsection{Constraints and guarded constants}

Now we present the rules for type checking with meta-variables. First we extend
the syntax of signatures to include guarded constants and add a new syntactic
category for user expressions:

\[\begin{array}{lcll}
    e & ::= & \LAM xe \Or x\,\bar e \Or c\,\bar e \Or \SET \Or \PI xee \Or ? \\
    C & ::= & \TypeConstr A B \Or \TermConstr M N A \Or
	      \TermConstr {\bar M} {\bar N} \Delta \\
    \Sigma & ::= & \ldots \Or
		\Ext \Sigma \ConstDecl p A M \Cs \\
\end{array}\]

The input to the type checking algorithm is a user expression which could
represent either a type or a term. Apart from the usual constructions user
expressions can also contain $?$ representing a meta-variable. During type
checking user expressions are translated into {\Core} terms where meta-variables are represented as fresh constants. Note that since we have domain
free lambda abstractions we cannot type check $\beta$-redexes. Hence the syntax
of user expressions disallows them.

A constraint $C$ is a conversion checking problem that has been postponed
because not enough information was available about the meta-variables. Since
our conversion checking algorithm is typed the constraints are also typed. The
constraints show up in the signature as guards to guarded constants. We write
$\ConstDecl p A M \Cs$ for a guarded constant $p$ of type $A$ and value $M$
guarded by the set of constraints $\Cs$.

We use lowercase greek letters $\alpha, \beta, \ldots$ for constants
representing meta-variables and $p$ and $q$ for guarded constants.

\subsection{Operations on the signature}

All rules work on a signature $\Sigma$, containing previously defined
constants, meta-variables, and guarded constants.
%
In other words we can write all judgements on the form
\[\ExplicitJudgement \Sigma J {\Sigma'}\]
%
To make the rules easier to read we first define a set of operations reading
and modifying the signature and when presenting the algorithm simply write $J$
for the judgement above. In rules with multiple premisses the signature is
threaded top-down, left-to-right. For instance,
\[\begin{array}{ccc}
{\small\begin{array}[c]{l}
\infer{J}
  {\begin{array}[b]{l}
     P_1
  \\ P_2
  \end{array}
  & P_3
  }
\end{array}}
& ~\mbox{is short-hand for}~
&
{\small\begin{array}[c]{l}
\infer{\ExplicitJudgement {\Sigma_1} J {\Sigma_4}}
  {\begin{array}[b]{l}
     \ExplicitJudgement {\Sigma_1} {P_1} {\Sigma_2}
  \\ \ExplicitJudgement {\Sigma_2} {P_2} {\Sigma_3}
  \end{array}
  & \ExplicitJudgement {\Sigma_3} {P_3} {\Sigma_4}
  }
\end{array}}
\end{array}\]

\begin{figure}
\begin{tabular}{llll}
%    \multicolumn2l{Operations on meta-variables} \\
    & $\ExplicitJudgement \Sigma
	{\AddMeta \alpha A}
	{\Ext \Sigma \MetaDecl \alpha A}
    $ & if & $\alpha \notin \Sigma$
    \\
    & $\ExplicitJudgement
	    \Sigma
	    {\InstMeta \alpha M}
	    {\Ext {\Sigma_1} \Ext {\IMetaDecl \alpha A M} \Sigma_2}
    $ & if & $\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\LookupMeta \alpha M}
% 	    \Sigma
%     $ & if & $\IMetaDecl \alpha A M ~\in~ \Sigma$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\Uninstantiated \alpha}
% 	    \Sigma
%     $ & if & $\MetaDecl \alpha A ~\in~ \Sigma$
    \\ {} \\
%    \multicolumn2l{Operations on guarded constants} \\
    & \multicolumn3l{$\ExplicitJudgement
	    \Sigma
	    {\AddConst p A M \Cs}
	    {\Ext \Sigma \ConstDecl p A M \Cs}
    $} \\
    & & if & $p \notin \Sigma$
%     \\
%     & \multicolumn3l{$\ExplicitJudgement
% 	    \Sigma
% 	    {\UpdateGuard p \Cs}
% 	    {\Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} \Sigma_2}
%     $} \\
%     & & if & $\Sigma ~=~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs^\prime} \Sigma_2$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\LookupConst p M}
% 	    \Sigma
%     $ & if & $\ConstDecl p A M \emptyset ~\in~ \Sigma$
%     \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\Guarded p}
% 	    \Sigma
%     $ & if & $\ConstDecl p A M \Cs ~\in~ \Sigma$ and $\Cs \neq \emptyset$
    \\ {} \\
%    \multicolumn2l{General operations} \\
    & $\ExplicitJudgement
	    \Sigma
	    {\LookupType c A}
	    \Sigma
    $ & if & $c : A \in \Sigma$
    \\
    & $\ExplicitJudgement
	    \Sigma
	    {\InScope \alpha M}
	    \Sigma
    $ & if & $\begin{array}[t]{ll}
	\Sigma ~=~ \Ext {\Sigma_1} \Ext {\MetaDecl \alpha A} \Sigma_2 ~~ \mbox{and}
	\\ c \in M ~~ \mbox{implies} ~~ c \in \Sigma_1
%     \\	\IsTypeCS {\Sigma_1} {} A ~~ \mbox{and} ~~ \HasTypeCS \Sigma {} M A ~~ \mbox{implies}
%     \\	\HasTypeCS {\Sigma_1} {} M A
    \end{array}$
    \\
%     & $\ExplicitJudgement
% 	    \Sigma
% 	    {\WithSig {\Sigma'} J}
% 	    {\Sigma''}
%     $ & if & $\ExplicitJudgement
% 	    {\Sigma'}
% 	    J
% 	    {\Sigma''}
%     $ \\
\end{tabular}
\caption{Operations on the signature}
\label{figOperations}
\end{figure}

We introduce two operations to manipulate meta-variables: $\AddMeta \alpha A$
adds a new meta-variable $\alpha$ of type $A$ to the signature, and $\InstMeta
\alpha M$ instantiates $\alpha$ to $M$.

%% Never used
% $\LookupMeta \alpha M$ looks up the
% value of an instantiated meta-variable, and $\Uninstantiated \alpha$ verifies
% that $\alpha$ is uninstantiated.

For guarded constants we just add the operation $\AddConst p A M \Cs$ to add a
new guarded constant to the signature.  In Section~\ref{secAlgorithm} we
explain the rules for solving the constraints of a guarded constant.

% , $\UpdateGuard p \Cs$ to update the guard of $p$,
% $\LookupConst p M$ to get the value of a guarded constant whose guard has been
% solved, and $\Guarded p$ to verify that the guard of $p$ has not been solved.

We also introduce the following general operations: $\LookupType c A$ looks up
the type $A$ of a constant $c$, and $\InScope \alpha M$ checks that $M$ is in
scope at the definition site of $\alpha$ (to ensure that $\alpha$ can be
instantiated to $M$).

%, and $\WithSig \Sigma J$ which checks $J$ in the signature $\Sigma$.

Detailed definitions of the operations can be found in
Figure~\ref{figOperations}.

\subsection{The algorithm} \label{secAlgorithm}

Next we present the type checking algorithm.  We use a bidirectional algorithm,
consisting of the following main judgement forms.

\[\begin{array}{ll}
    \IsType e A & \mbox{well-formed types} \\
    \CheckType e A M & \mbox{type checking} \\
    \InferType e A M & \mbox{type inference} \\
    \EqualType A B \Cs & \mbox{type conversion} \\
    \Equal M N A \Cs & \mbox{term conversion} \\
\end{array}\]

The rules for well-formed types and type checking and inference takes an
expression in the user syntax produces a type or term in {\Core} which is a
well-formed approximation of the user expression. Conversion checking produces
a set of unsolved constraints which needs to be solved for the judgement to be
true in {\Core}. The exact form of type checking algorithm used is not very
important--a unidirectional algorithm would also work. What is important is
that computation is performed on the well-typed approximations rather than the
user expressions.

We use typed conversion for two reasons: it is a nice way to implement
$\eta$-equality, and perhaps more importantly to prove the correctness of the
algorithm we need the invariant that when checking $\Equal M N A \Cs$ we have
$\HasTypeC \Gamma M A$ and $\HasTypeC \Gamma N A$, so we need to record the
type to make sure the invariant is preserved.

When checking conversion we also need the following judgement forms.

\[\begin{array}{ll}
    \EqualWhnf M N A \Cs & \mbox{conversion of weak head normal forms} \\
    \Equal {\bar M} {\bar N} \Delta \Cs & \mbox{conversion of sequences of terms} \\
\end{array}\]

In the following we let $J$ range over judgements of these seven forms.

\subsubsection{Normalisation}

Type checking with dependent types involves normalising arbitrary (type
correct) terms, so we need to know how to normalise terms in signature
containing meta-variables and guarded constants. We do this simply by
translating the signature to {\Core} and performing the normalisation in
{\Core}.

\begin{definition}
    Given a signature $\Sigma$ containing meta-variables and guarded constants
    we can recover its {\Core} restriction $\CoreSig \Sigma$ by replacing
    guarded constants with normal constants, retaining the definition if the
    guard is empty and removing it otherwise.
\end{definition}

We write $\Sigma$ for $\CoreSig \Sigma$ when it is clear from the context that
the latter is intended. For instance, we write $\HasTypeCS \Sigma \Gamma M A$
rather than $\HasTypeCS {\CoreSig \Sigma} \Gamma M A$. The type checking rules
maintain the invariant that the {\Core} restriction of the current signature is
well-formed.

We write $\ExplicitJudgement \Sigma {\whnf M {M'}} \Sigma$ if $M'$ is the weak
head normal form of $M$ in $\CoreSig \Sigma$. Similarly $\Normalise M {M'}$
means that $M'$ is the normal form of $M$.

\subsubsection{Type checking rules}

To save some space we omit the rules for checking well-formed types and most of
the rules for type checking and inference. The rules are simple extensions of
the standard type checking algorithm\TODO{cite core paper} to produce
well-typed terms. The interesting type checking rules are those for type
checking meta-variables and the conversion rules.

\URules{

\infer{ \CheckType {?} A {\alpha \, \Gamma }}
{\begin{array}{l}
    \AddMeta \alpha {\Gamma \to A}
\end{array}}

\quad

\infer{
    \CheckType e A M
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \emptyset
\end{array}}

\quad

\infer{
    \CheckType e A {p\,\Gamma}
}{\begin{array}{l}
    \InferType e B M
\\  \EqualType A B \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A} {\LAM \Gamma M} \Cs
\end{array}}

}

When type checking a user meta-variable we add a fresh meta-variable to the
signature and return this. Since meta-variables are part of the signature they
have to be lifted to the top-level\TODO{cite something here?}.

We have two versions of the conversion rule. The first corresponds to the
normal conversion rule and applies when no constraints are left over. The
interesting case is when we cannot safely conclude that $A = B$, in which case
we introduce a fresh guarded constant. As for meta-variables, guarded constants
are lifted to the top-level.

\subsubsection{Type conversion rules}

When checking conversion of two function types, an interesting question is what
to do when comparing the domains gives rise to constraints. The rule in question is

\URules{
% (x : A) -> B = (x : A') -> B'
\infer{
    \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} {\Cs \cup \Cs^\prime}
}{\begin{array}{l}
    \EqualType {A_1} {A_2} \Cs, ~~ \Cs \neq \emptyset
\\  \AddConst p {\Gamma \to A_1 \to A_2} {\LAM {\Gamma\,x} x} \Cs
\\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {\SubstD {B_2} {p ~ \Gamma \, x}} {\Cs^\prime}
\end{array}}
}

To ensure the correctness of the algorithm we need to maintain the invariant
that when we check $\EqualType A B \Cs$ we have $\IsTypeC \Gamma A$ and
$\IsTypeC \Gamma B$. Thus if we do not know whether $A_1 = A_2$ it is not
correct to check $\EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {B_2} {\Cs^\prime}$
since $B_2$ is not well-formed in $\Ext \Gamma x : A_1$. To solve the problem
we substitute a guarded constant for $x$ in $B_2$.

% \quad
% 
% \infer{
%     \EqualType {\PI x {A_1} {B_1}} {\PI x {A_2} {B_2}} \Cs
% }{\begin{array}{l}
%     \EqualType {A_1} {A_2} \emptyset
% \\  \EqualTypeCtx {\Ext \Gamma x : A_1} {B_1} {B_2} \Cs
% \end{array}}
% 
%  \\{}\\
% 
% % El M = El N
% 
% \infer{
%     \EqualType {\EL M} {\EL N} \Cs
% }{\begin{array}{l}
%     \Equal M N \SET \Cs
% \end{array}}
% 
% \end{array}\]}

\subsubsection{Term conversion rules}

Checking conversion of terms is done on weak head normal forms. The only rule
that is applied before weak head normalisation is the $\eta$-rule.

\URules{

% Eta

\infer{
    \Equal M N {\PI x A B} \Cs
}{\begin{array}{l}
    \EqualCtx {\Ext \Gamma x : A} {M \, x} {N \, x} B \Cs
\end{array}}

\qquad

% Weak head normalisation

\infer{
    \Equal M N A \Cs
}{\begin{array}[b]{lcl}
    \whnf M {M'}
\\  \whnf N {N'}
&&  \EqualWhnf {M'} {N'} A \Cs
\end{array}
}

}

In {\Core} function types are not terms so a meta-variable can never be
instantiated to a function type. If this was the case we would have to check if
the type was a meta-variable, and if so postpone the constraint, since we would
not know whether or not the $\eta$-rule should be applied.

The weak head normal forms we compare will be of atomic type and so they are of
the form $h\,\bar M$ where the head $h$ is a variable, constant, meta-variable,
or guarded constant. If both terms have the same variable or constant head $h :
\Delta \to A$ we compare the arguments in $\Delta$.

\URules{

\infer{
    \EqualWhnf {h ~ \bar M} {h ~ \bar N} A \Cs
}{\begin{array}{lcl}
    h : \Delta \to B
&&   \Equal {\bar M} {\bar N} \Delta \Cs
\end{array}}
}

If one of the heads is a guarded constant we give up and return the problem as
a constraint.

\URules{
\infer{
    \EqualWhnf {p ~ \bar M} N A {\left\{\TermConstr {p ~ \bar M} N A\right\}}
}{}
}

What to do when we encounter a meta-variable depends on what we are using the
meta-variables for. If they are used purely for interaction we would treat them
in the same way as the guarded constants. In our case we are interested in
implicit arguments, so we try to find unique instantiations to the meta-variables. For simplicity, we use a restricted form of pattern
unification\TODO{Cite pattern unification paper}, but there is no
reason to believe that our correctness proof would not extend to full pattern
unification. In the examples we have studied, using meta-variables for implicit
arguments, this simpler form of unification seems to be sufficient.

\URules{

% Instantiation

\infer{
    \EqualWhnf {\alpha ~ \bar x} M A \emptyset
}{
\begin{array}[b]{l}
    \bar x~\mathit{distinct}
\\  \Normalise M {M'}
\\  \FV {M'} \subseteq \bar x
\end{array}
& \begin{array}[b]{l}
    \InScope \alpha {\LAM {\bar x} M'}
\\  \InstMeta \alpha {\LAM {\bar x} M'}
\end{array}
}
}

Given the problem $\alpha \, \bar x = M$ we would like to instantiate $\alpha$ to
$\LAM {\bar x} M$. This is only correct if $\bar x$ are distinct variables, $M$
does not contain any variables other than $\bar x$, and any constants refered
to by $M$ are in scope at the declaration site of $\alpha$. Now $M$ might refer
to meta-variables introduced after $\alpha$ but which have been instantiated.
For this reason we normalise $M$ to $M'$ and try to instantiate $\alpha$ to
$\LAM {\bar x} M'$. A possible optimisation might be to only normalise if $M$
contains out-of-scope constants or variables.

Finally we present the rules to check conversion of argument lists. The
interesting case is when comparing the first arguments results in some unsolved
constraints.

\URules{

% No constraints

% \infer{
%     \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \Cs
% }{\begin{array}{l}
%     \Equal M N A \emptyset
% \\  \Equal {\bar M} {\bar N} {\SubstD \Delta M} \Cs
% \end{array}}
% 
% \\{}\\

% Some constraints

\Rule{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {~~} \\
    \hfill \left\{ \TermConstr {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} \right\}
}{\begin{array}{lcl}
    \Equal M N A \Cs \neq \emptyset
&&  x \in \FV \Delta
\end{array}}

\quad

\Rule{
    \Equal {M, \, \bar M} {N, \, \bar N} {(x : A) \Delta} {\Cs_1 \cup \Cs_2}
}{\begin{array}{lcl}
    \Equal M N A {\Cs_1} \neq \emptyset
\\  \Equal {\bar M} {\bar N} \Delta {\Cs_2}
&& x \notin \FV \Delta
\end{array}}

}

If the value of the first argument is used in the types of later arguments ($x
\in \FV \Delta$) we have to stop and produce a constraint since the types of
$\bar M$ and $\bar N$ differ. If on the other hand the types of later arguments
are independent of the value of the first argument, we can proceed and compare
them without knowing whether the first arguments are convertible.

There is a possible inefficiency in that the constraint produced in the first
case does not remember the result of comparing $M$ and $N$. This could be
remedied by giving more structure to the constraint sets, requiring that the
constraints in $\Cs$ are solved before comparing $\bar M$ and $\bar N$.

\subsubsection{Constraint Solving}

So far, we have not looked at when or how the guards of a constant are
simplified or solved. In principle this can be done at any time, for instance
as a separate phase after type checking. In practise, however, it might be a
better idea to interleave constraint solving and type checking. In
Section~\ref{secProof} we prove that this can be done safely.

Constraint solving amounts to rechecking the guard of a constant. The notation
$\CheckConstr \Cs {\Cs^\prime}$ means checking each of the constraints in $\Cs$
and taking $\Cs^\prime$ to be the union of the results.

% Constraint solving
\URules{
    \infer{
	\ExplicitJudgement
	    \Sigma
	    \Simplify
	    {\Ext {\Sigma^\prime_1} \Ext {\ConstDecl p A M {\Cs^\prime}} \Sigma_2}
    }{\begin{array}{ll}
	\multicolumn2l{\Sigma ~ = ~ \Ext {\Sigma_1} \Ext {\ConstDecl p A M \Cs} {\Sigma_2}} \\
	\ExplicitJudgement {\Sigma_1} {\CheckConstr \Cs {\Cs^\prime}} {\Sigma^\prime_1} 
	% & \Cs \neq {\Cs^\prime} \\
    \end{array}
    }
}

% Not used
% \begin{definition}[Normal signature]
%     A signature $\Sigma$ is in {\em normal form} if it is not the case that
%     $\ExplicitJudgement \Sigma \Simplify {\Sigma^\prime}$ for some $\Sigma^\prime$.
% \end{definition}

\if \NoteOnPatternMatching 1
\subsection{Adding pattern matching} \label{secAddPatternMatching}

Some notes on how to add pattern matching.
\fi

% Blocked terms
% \URules{
%     \infer{
% 	\Blocked {c \, \bar M}
%     }{\begin{array}{l}
% 	c ~ \mbox{pattern matches on its $i^\mathrm{th}$ argument}
%     \\	M_i = \alpha \, \bar N ~ or ~ M_i = p \, \bar N ~ or ~ \Blocked {M_i}
%     \end{array}}
% 
% \qquad
% 
% \infer{
%     \Equal M N A {\left\{ \TermConstr {M'} {N'} A \right\}}
% }{\begin{array}[b]{l}
%     \whnf M {M'}
% \\  \whnf N {N'}
% \\  \Blocked {M'} ~ \mathit{or} ~ \Blocked {N'}
% \end{array}
% }
% }

