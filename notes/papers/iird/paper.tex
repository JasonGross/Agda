\documentclass[11pt]{article}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
\makeatletter

\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{1mm}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\makeatother















\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{color}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

% Enables greek letters in math environment
\everymath{\SetUnicodeOption{mathletters}}
\everydisplay{\SetUnicodeOption{mathletters}}

% This makes sure that local glyph overrides below are
% chosen.
\DeclareUnicodeOption{localDefs}
\SetUnicodeOption{localDefs}

% For some reason these macros need to be defined.
\newcommand{\textmu}{$\mu$}
\newcommand{\textnu}{$\nu$}

% This character doesn't seem to be defined by ucs.sty.
\DeclareUnicodeCharacter{"21A6}{\ensuremath{\mapsto}}

\input{macros}

\title{Encoding indexed inductive types using the identity type}
\author{Ulf Norell}

\begin{document}
\maketitle
\begin{abstract}
    An indexed inductive-recursive definition (IIRD) simultaneously defines an
    indexed family of sets and a recursive function over this family.  This
    notion is sufficiently powerful to capture essentially all definitions of
    sets in Martin-Löf type theory.

    I show that it is enough to have one particular indexed inductive type,
    namely the intensional identity relation, to be able to interpret all IIRD
    as non-indexed definitions.
    
    The proof is formally verified in Agda.
\end{abstract}

\section{Introduction}

% Describe the current state of affairs

Indexed induction recursion is the thing.

% Indentify gap

Dybjer and Setzer~\cite{dybjer:indexed-ir} show that in an extensional theory
generalised IIRD can be interpreted by restricted IIRD~\cite{dybjer:jsl}. We're
not using an extensional theory though.

\TODO{What's the relation between restricted IIRD and IRD?}

% Fill gap

I improve on this result showing that it is enough to add intensional equality.
The proof is formalised in Agda.

Non-indexed definitions are simpler(?), so if can get away with just adding the
identity type we get simpler meta theory that if we would add indexed
definitions directly.

\section{The Logical Framework}

    Martin-Löf's logical framework~\cite{nordstrom:book} extended with sigma
    types ($\SIGMA x A B$), $\Zero$, $\One$, and $\Two$.

    \TODO{what about $Π$ in Set? Used on the meta level but probably not on the object level.}

    $\HasType {Γ} x A$

    $\IsType {Γ} A$

    $\PI x A B$

    $\SIGMA x A B$

\section{The Identity Type}

There are many versions.

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{11}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{11}{{}(==){}}
\fromto{11}{E}{{}\mathrel{:}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}\to \Conid{A}\to \Conid{A}\to \Set{}}
\nextline
\fromto{5}{11}{{}\mathsf{refl}{}}
\fromto{11}{E}{{}\mathrel{:}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Varid{x}\mathrel{:}\Conid{A})\to \Varid{x}==\Varid{x}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Martin-Löf identity relation, introduced in 1973~\cite{martin-lof:predicative}.

\begin{definition}[Martin-Löf elimination]

The Martin-Löf elimination rule (sometimes called $J$) has the type

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{12}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{12}{{}\Varid{elim\char95 ML}\mathrel{:}{}}
\fromto{12}{E}{{}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Conid{C}\mathrel{:}(\Varid{x},\Varid{y}\mathrel{:}\Conid{A})\to \Varid{x}==\Varid{y}\to \Set)\to {}}
\nextline
\fromto{12}{E}{{}((\Varid{x}\mathrel{:}\Conid{A})\to \Conid{C}\;\Varid{x}\;\Varid{x}\;(\mathsf{refl}\;\Varid{x}))\to {}}
\nextline
\fromto{12}{E}{{}(\Varid{x},\Varid{y}\mathrel{:}\Conid{A})\;(\Varid{p}\mathrel{:}\Varid{x}==\Varid{y})\to \Conid{C}\;\Varid{x}\;\Varid{y}\;\Varid{p}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

and the corresponding computation rule is
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\Varid{elim\char95 ML}\;\Conid{C}\;\Varid{h}\;\Varid{x}\;\Varid{x}\;(\mathsf{refl}\;\Varid{x})\mathrel{=}\Varid{h}\;\Varid{x}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{definition}

\begin{definition}[Paulin elimination]
Paulin identity relation~\cite{pfenning-paulin:inductive-coc}.

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{11}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{11}{{}\Varid{elim\char95 P}\mathrel{:}{}}
\fromto{11}{E}{{}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Varid{x}\mathrel{:}\Conid{A})\;(\Conid{C}\mathrel{:}(\Varid{y}\mathrel{:}\Conid{A})\to \Varid{x}==\Varid{y}\to \Set)\to {}}
\nextline
\fromto{11}{E}{{}\Conid{C}\;\Varid{x}\;(\mathsf{refl}\;\Varid{x})\to (\Varid{y}\mathrel{:}\Conid{A})\;(\Varid{p}\mathrel{:}\Varid{x}==\Varid{y})\to \Conid{C}\;\Varid{y}\;\Varid{p}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

The corresponding computation rule is
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\Varid{elim\char95 P}\;\Varid{x}\;\Conid{C}\;\Varid{h}\;\Varid{x}\;(\mathsf{refl}\;\Varid{x})\mathrel{=}\Varid{h}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{definition}

\begin{lemma}
    Martin-Löf elimination can be defined in terms of Paulin elimination.
\end{lemma}

\begin{proof}

Trivial.
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\Varid{elim\char95 ML}\;\Conid{C}\;\Varid{h}\;\Varid{x}\;\Varid{y}\;\Varid{p}\mathrel{=}\Varid{elim\char95 P}\;\Varid{x}\;(\lambda \Varid{z}\;\Varid{q}.~\Conid{C}\;\Varid{x}\;\Varid{z}\;\Varid{q})\;(\Varid{h}\;\Varid{x})\;\Varid{y}\;\Varid{p}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{proof}

\begin{lemma}
    Paulin elimination can be defined in terms of Martin-Löf elimination.
\end{lemma}

\begin{proof}
    This proof is slightly more involved.

    We first define the substitution rule
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{14}{@{}l@{}}
\column{33}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{14}{{}\Varid{subst}\mathrel{:}{}}
\fromto{14}{E}{{}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Conid{C}\mathrel{:}\Conid{A}\to \Set)\;(\Varid{x},\Varid{y}\mathrel{:}\Conid{A}){}}
\nextline
\fromto{14}{E}{{}\Varid{x}==\Varid{y}\to \Conid{C}\;\Varid{x}\to \Conid{C}\;\Varid{y}{}}
\nextline
\fromto{5}{33}{{}\Varid{subst}\;\Conid{C}\;\Varid{x}\;\Varid{y}\;\Varid{p}\;\Conid{Cx}\mathrel{=}\Varid{elim\char95 ML}\;{}}
\fromto{33}{E}{{}(\lambda \Varid{a}\;\Varid{b}\;\Varid{q}.~\Conid{C}\;\Varid{a}\to \Conid{C}\;\Varid{b})\;{}}
\nextline
\fromto{33}{E}{{}(\lambda \Varid{a}\;\Conid{Ca}.~\Conid{Ca})\;\Varid{x}\;\Varid{y}\;\Varid{p}\;\Conid{Cx}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

    Now define

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}\Conid{E}\mathrel{:}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Varid{x}\mathrel{:}\Conid{A})\to \Set{}}
\nextline
\fromto{5}{E}{{}\Conid{E}\;\Varid{x}\mathrel{=}(\Varid{y}\mathrel{:}\Conid{A})×(\Varid{x}==\Varid{y}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

    We can prove that any element of \ensuremath{\Conid{E}\;\Varid{x}} is in fact equal to \ensuremath{(\Varid{x},\mathsf{refl}\;\Varid{x})}.

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}\Varid{uniqE}\mathrel{:}\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Varid{x},\Varid{y}\mathrel{:}\Conid{A})\;(\Varid{p}\mathrel{:}\Varid{x}==\Varid{y})\to (\Varid{x},\mathsf{refl}\;\Varid{x})==(\Varid{y},\Varid{p}){}}
\nextline
\fromto{5}{E}{{}\Varid{uniqE}\mathrel{=}\Varid{elim}\;(\lambda \Varid{x}\;\Varid{y}\;\Varid{p}.~(\Varid{x},\mathsf{refl}\;\Varid{x})==(\Varid{y},\Varid{p}))\;\mathsf{refl}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{31}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{31}{{}\Varid{elim\char95 P}\;\Varid{x}\;\Conid{C}\;\Varid{h}\;\Varid{y}\;\Varid{p}\mathrel{=}\Varid{subst}\;{}}
\fromto{31}{E}{{}(\lambda \Varid{z}.~\Conid{C}\;(π_0\;\Varid{z})\;(π_1\;\Varid{z}))\;{}}
\nextline
\fromto{31}{E}{{}(\Varid{x},\mathsf{refl}\;\Varid{x})\;(\Varid{y},\Varid{p})\;(\Varid{uniqE}\;\Varid{x}\;\Varid{y}\;\Varid{p})\;\Varid{h}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

    Note that in an impredicative setting there is a simpler proof due to
    Streicher~\cite{streicher:habilitation}.

\end{proof}

\begin{theorem}
    Martin-Löf elimination and Paulin elimination are equivalent.
\end{theorem}

Streicher axiom K. Not valid~\cite{HofmannM:gromru}. Fortunately we don't need it.

In the following we will use Paulin elimination.

\section{Indexed Inductive Datatypes} \label{sec-IID}

In this section we present the formalisation of indexed inductive types. We
follow the formalisation of indexed induction recursion of Dybjer and
Setzer~\cite{dybjer:indexed-ir} but leave out the recursion to simplify the
presentation.

\subsection{Codes for IID} \label{sec-IID-Codes}

In accordance with Dybjer and Setzer we introduce a common type of codes which
will serve both as codes for general IID and restricted IID.

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{10}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{E}{{}\mathbf{data}\;\mathit{OP}\;(\Conid{I}\mathrel{:}\Set)\;(\Conid{E}\mathrel{:}\Set)\;\mathbf{where}{}}
\nextline
\fromto{B}{3}{{}\hsindent{3}{}}
\fromto{3}{10}{{}ι{}}
\fromto{10}{E}{{}\mathrel{:}\Conid{E}\to \mathit{OP}\;\Conid{I}\;\Conid{E}{}}
\nextline
\fromto{B}{3}{{}\hsindent{3}{}}
\fromto{3}{10}{{}σ{}}
\fromto{10}{E}{{}\mathrel{:}(\Conid{A}\mathrel{:}\Set)\;(γ\mathrel{:}\Conid{A}\to \mathit{OP}\;\Conid{I}\;\Conid{E})\to \mathit{OP}\;\Conid{I}\;\Conid{E}{}}
\nextline
\fromto{B}{3}{{}\hsindent{3}{}}
\fromto{3}{10}{{}δ{}}
\fromto{10}{E}{{}\mathrel{:}(\Conid{A}\mathrel{:}\Set)\;(\Varid{i}\mathrel{:}\Conid{A}\to \Conid{I})\;(γ\mathrel{:}\mathit{OP}\;\Conid{I}\;\Conid{E})\to \mathit{OP}\;\Conid{I}\;\Conid{E}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Now the codes for general indexed inductive types are defined by \ensuremath{\mathit{OP}^g\;\Conid{I}\mathrel{=}\mathit{OP}\;\Conid{I}\;\Conid{I}}, and the codes for restricted types are \ensuremath{\mathit{OP}^r\;\Conid{I}\mathrel{=}\Conid{I}\to \mathit{OP}\;\Conid{I}\;\mathbf{1}}. The intuition
is that for general IID the index is computed from the shape of the value,
whereas the index of a restricted IID is given beforehand. With these
definitions in mind, let us study the type of codes in more detail. We have
three constructors:
\begin{itemize}
    \item
        Base case: \ensuremath{ι\;\Varid{e}}. This corresponds to an IID with no arguments to the
        constructor. In the case of a general IID we have to give the index for
        the constructor. For instance the code for the singleton type of true
        booleans given by \ensuremath{\Conid{IsTrue}\mathrel{:}\Conid{Bool}\to \Set} and introduction rule \ensuremath{\Conid{IsTrue}\;\Varid{true}} is
        \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{13}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{13}{E}{{}ι\;\Varid{true}\mathrel{:}\mathit{OP}^g\;\Conid{Bool}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    \item
        Non-inductive argument: \ensuremath{σ\;\Conid{A}\;γ}. In this case the constructor
        has a non-inductive argument \ensuremath{\Varid{a}\mathrel{:}\Conid{A}}. The remaining arguments may depend
        on \ensuremath{\Varid{a}} and are coded by \ensuremath{γ\;\Varid{a}}. For instance, a datatype with
        \ensuremath{\Varid{n}} constructors can be coded by \ensuremath{σ\;\mathit{Fin}_n\;γ}, where \ensuremath{\mathit{Fin}_n} is
        an \ensuremath{\Varid{n}} element type and \ensuremath{γ\;\Varid{i}} is the code for the \ensuremath{\Varid{i}}th constructor.

        Another example is the type of pairs over \ensuremath{\Conid{A}} and \ensuremath{\Conid{B}}
        \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{13}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{13}{E}{{}\lambda \Varid{i}.~σ\;\Conid{A}\;(\lambda \Varid{a}.~σ\;\Conid{B}\;(\lambda \Varid{b}.~ι\;\star))\mathrel{:}\mathit{OP}^r\;\mathbf{1}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
        In this case the following arguments do not depend on the value of the
        non-inductive arguments.
    \item
        Inductive argument: \ensuremath{δ\;\Conid{A}\;\Varid{i}\;γ}. For an inductive argument we
        need to know the index of the argument. Note that the following
        arguments cannot depend on the value of the inductive argument. The
        inductive argument may occur under some assumptions \ensuremath{\Conid{A}}. For example
        consider the accessible part of a relation \ensuremath{<} over \ensuremath{\Conid{A}}, \ensuremath{\Conid{Acc}\mathrel{:}\Conid{A}\to \Set} with introduction rule that for any \ensuremath{\Varid{x}}, if \ensuremath{((\Varid{y}\mathrel{:}\Conid{A})\to \Varid{y}<\Varid{x}\to \Conid{Acc}\;\Varid{y})} then \ensuremath{\Conid{Acc}\;\Varid{x}}. Here the inductive argument \ensuremath{\Conid{Acc}\;\Varid{y}} occurs
        under the assumptions \ensuremath{(\Varid{y}\mathrel{:}\Conid{A})} and \ensuremath{\Varid{y}<\Varid{x}}. The code for this type is
        \begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{13}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{13}{E}{{}\lambda \Varid{x}.~δ\;((\Varid{y}\mathrel{:}\Conid{A})×(\Varid{y}<\Varid{x}))\;π_0\;(ι\;\star)\mathrel{:}\mathit{OP}^r\;\Conid{A}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
        The index of the inductive argument is \ensuremath{\Varid{y}} which is the first projection
        of the assumptions.
\end{itemize}
See Section~\ref{sec-IID-Examples} for more examples.

\subsection{From codes to types} \label{sec-IID-Types}

Now that we have defined the codes for IID the next step is to describe their
semantics, i.e. what the elements of an IID with a given code are. First we
define the type of arguments to the constructor parameterised by the type of
inductive arguments\footnote{Analogous to when you for simple inductive types
define an inductive type as the fixed point of some functor.}.
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{25}{@{}l@{}}
\column{28}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{E}{{}\mathit{Args}_{I,E}\mathrel{:}(γ\mathrel{:}\mathit{OP}\;\Conid{I}\;\Conid{E})\;(\Conid{U}\mathrel{:}\Conid{I}\to \Set)\to \Set{}}
\nextline
\fromto{B}{25}{{}\Conid{Args}\;(ι\;\Varid{e})\;{}}
\fromto{25}{28}{{}\Conid{U}{}}
\fromto{28}{E}{{}\mathrel{=}\mathbf{1}{}}
\nextline
\fromto{B}{25}{{}\Conid{Args}\;(σ\;\Conid{A}\;γ)\;{}}
\fromto{25}{28}{{}\Conid{U}{}}
\fromto{28}{E}{{}\mathrel{=}\Conid{A}×\lambda \Varid{a}.~\Conid{Args}\;(γ\;\Varid{a})\;\Conid{U}{}}
\nextline
\fromto{B}{25}{{}\Conid{Args}\;(δ\;\Conid{A}\;\Varid{i}\;γ)\;{}}
\fromto{25}{28}{{}\Conid{U}{}}
\fromto{28}{E}{{}\mathrel{=}((\Varid{a}\mathrel{:}\Conid{A})\to \Conid{U}\;(\Varid{i}\;\Varid{a}))×\lambda \Varid{d}.~\Conid{Args}\;γ\;\Conid{U}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
There are no surprises here, in the base case there are no arguments, in the
non-inductive case there is one argument \ensuremath{\Varid{a}\mathrel{:}\Conid{A}} followed by the rest of the
arguments (which may depend on \ensuremath{\Varid{a}}). In the inductive case we have a function
from the assumptions \ensuremath{\Conid{A}} to a value of the inductive type at the specified
index.

For general IID we also need to be able to compute the index of a given
constructor argument.
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{26}{@{}l@{}}
\column{29}{@{}l@{}}
\column{37}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{E}{{}\mathit{index}_{I,E}\mathrel{:}(γ\mathrel{:}\mathit{OP}\;\Conid{I}\;\Conid{E})\;(\Conid{U}\mathrel{:}\Conid{I}\to \Set)\;(\Varid{a}\mathrel{:}\Conid{Args}\;γ\;\Conid{U})\to \Conid{E}{}}
\nextline
\fromto{B}{26}{{}\Varid{index}\;(ι\;\Varid{e})\;{}}
\fromto{26}{29}{{}\Conid{U}\;{}}
\fromto{29}{37}{{}\anonymous {}}
\fromto{37}{E}{{}\mathrel{=}\Varid{e}{}}
\nextline
\fromto{B}{26}{{}\Varid{index}\;(σ\;\Conid{A}\;γ)\;{}}
\fromto{26}{29}{{}\Conid{U}{}}
\fromto{29}{37}{{}\left\langle\Varid{x},\Varid{a}\right\rangle{}}
\fromto{37}{E}{{}\mathrel{=}\Varid{index}\;(γ\;\Varid{x})\;\Conid{U}\;\Varid{a}{}}
\nextline
\fromto{B}{26}{{}\Varid{index}\;(δ\;\Conid{A}\;\Varid{i}\;γ)\;{}}
\fromto{26}{29}{{}\Conid{U}{}}
\fromto{29}{37}{{}\left\langle\anonymous ,\Varid{a}\right\rangle{}}
\fromto{37}{E}{{}\mathrel{=}\Varid{index}\;γ\;\Conid{U}\;\Varid{a}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
Note that only the non-inductive arguments are used when computing the index.

This is all the machinery needed to define the types of general and restricted
IID. For restricted IID we have, given \ensuremath{γ\mathrel{:}\mathit{OP}^r\;\Conid{I}} and \ensuremath{\Varid{i}\mathrel{:}\Conid{I}}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}U^r_γ\mathrel{:}\Conid{I}\to \Set{}}
\nextline
\fromto{5}{E}{{}\mathrm{intro}^r_γ\;\Varid{i}\mathrel{:}\Conid{Args}\;(γ\;\Varid{i})\;U^r_γ\to U^r_γ\;\Varid{i}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
For general IID, given \ensuremath{γ\mathrel{:}\mathit{OP}^g\;\Conid{I}} we have
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}U^g_γ\mathrel{:}\Conid{I}\to \Set{}}
\nextline
\fromto{5}{E}{{}\mathrm{intro}^g_γ\mathrel{:}(\Varid{a}\mathrel{:}\Conid{Args}\;γ\;U^g_γ)\to U^g_γ\;(\Varid{index}\;γ\;U^g_γ\;\Varid{a}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

As an example take the type of pairs over \ensuremath{\Conid{A}} and \ensuremath{\Conid{B}}:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}γ\mathrel{=}\lambda \Varid{i}.~σ\;\Conid{A}\;(\lambda \Varid{a}.~σ\;\Conid{B}\;(\lambda \Varid{b}.~ι\;\star))\mathrel{:}\mathit{OP}^r\;\mathbf{1}{}}
\nextline
\fromto{5}{E}{{}\Conid{Pair}\;\Conid{A}\;\Conid{B}\mathrel{=}U^r_γ\mathrel{:}\mathbf{1}\to \Set{}}
\nextline
\fromto{5}{E}{{}\mathrm{intro}^r_γ\;\star\mathrel{:}\Conid{A}×(\lambda \Varid{a}.~\Conid{B}×(\lambda \Varid{b}.~\mathbf{1}))\to \Conid{Pair}\;\Conid{A}\;\Conid{B}\;\star{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

Note that while the index of a restricted IID is determined from the outside we
still allow so called nested types~\cite{bird98nested}. An example of this is
the accessibility predicate given in Section~\ref{sec-IID-Codes}. This is
crucial when interpreting general IID by restricted IID (see
Section~\ref{sec-Encoding}).

\subsection{Elimination rules} \label{sec-IID-Elimination}

\subsection{Examples} \label{sec-IID-Examples}

Intensional identity relation (Paulin version).

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{E}{{}\mathbf{data}\;(==)\{\mskip1.5mu \Conid{A}\mathrel{:}\Set\mskip1.5mu\}(\Varid{x}\mathrel{:}\Conid{A})\mathrel{:}\Conid{A}\to \Set\;\mathbf{where}{}}
\nextline
\fromto{B}{5}{{}\hsindent{5}{}}
\fromto{5}{E}{{}\mathsf{refl}\mathrel{:}\Varid{x}==\Varid{x}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

The elimination rule for this type is Paulin elimination.

\section{Encoding} \label{sec-Encoding}

Just add a proof that the index is the right one.

Example:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{9}{@{}l@{}}
\column{17}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}\mathbf{data}\;\Conid{Even}\mathrel{:}\Conid{Nat}\to \Set\;\mathbf{where}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{17}{{}\mathsf{evenZ}{}}
\fromto{17}{E}{{}\mathrel{:}\Conid{Even}\;\mathsf{z}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{17}{{}\mathsf{evenSS}{}}
\fromto{17}{E}{{}\mathrel{:}\{\mskip1.5mu \Varid{n}\mathrel{:}\Conid{Nat}\mskip1.5mu\}\to \Conid{Even}\;\Varid{n}\to \Conid{Even}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{n})){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

    The corresponding elimination rule is:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{9}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}elim_{Even}\mathrel{:}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{E}{{}(\Conid{C}\mathrel{:}(\Varid{n}\mathrel{:}\Conid{Nat})\to \Conid{Even}\;\Varid{n}\to \Set)\to {}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{E}{{}\Conid{C}\;\mathsf{z}\;\mathsf{evenZ}\to {}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{E}{{}((\Varid{n}\mathrel{:}\Conid{Nat})\;(\Varid{e}\mathrel{:}\Conid{Even}\;\Varid{n})\to \Conid{C}\;\Varid{n}\;\Varid{e}\to \Conid{C}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{n}))\;(\mathsf{evenSS}\;\Varid{e}))\to {}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{E}{{}(\Varid{n}\mathrel{:}\Conid{Nat})\;(\Varid{e}\mathrel{:}\Conid{Even}\;\Varid{n})\to \Conid{C}\;\Varid{n}\;\Varid{e}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

As a non-indexed type

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{9}{@{}l@{}}
\column{18}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{E}{{}\mathbf{data}\;\mathit{Even}^{*}\;(\Varid{n}\mathrel{:}\Conid{Nat})\mathrel{:}\Set\;\mathbf{where}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{18}{{}\mathsf{evenZ}^{*}{}}
\fromto{18}{E}{{}\mathrel{:}\mathsf{z}==\Varid{n}\to \mathit{Even}^{*}\;\Varid{n}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{18}{{}\mathsf{evenSS}^{*}{}}
\fromto{18}{E}{{}\mathrel{:}(\Varid{m}\mathrel{:}\Conid{Nat})\to \Conid{Even}\;\Varid{m}\to \mathsf{s}\;(\mathsf{s}\;\Varid{m})==\Varid{n}\to \mathit{Even}^{*}\;\Varid{n}{}}
\nextline[\blanklineskip]
\fromto{5}{E}{{}\mathsf{evenZ}\mathrel{:}\mathit{Even}^{*}\;\mathsf{z}{}}
\nextline
\fromto{5}{E}{{}\mathsf{evenZ}\mathrel{=}\mathsf{evenZ}^{*}\;\mathsf{refl}{}}
\nextline[\blanklineskip]
\fromto{5}{E}{{}\mathsf{evenSS}\mathrel{:}(\Varid{n}\mathrel{:}\Conid{Nat})\to \Conid{Even}\;\Varid{n}\to \Conid{Even}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{n})){}}
\nextline
\fromto{5}{E}{{}\mathsf{evenSS}\;\Varid{n}\;\Varid{e}\mathrel{=}\mathsf{evenSS}^{*}\;\Varid{n}\;\Varid{e}\;\mathsf{refl}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

    To define the elimination rule we eliminate the proof that the index is the
    expected one. 

    The elimination rule in deduction style: We have
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{8}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{8}{{}\Varid{hz}{}}
\fromto{8}{E}{{}\mathrel{:}\Conid{C}\;\Varid{z}\;\mathsf{evenZ}{}}
\nextline
\fromto{3}{8}{{}\Varid{hss}{}}
\fromto{8}{E}{{}\mathrel{:}(\Varid{n}\mathrel{:}\Conid{Nat})\;(\Varid{e}\mathrel{:}\Conid{Even}\;\Varid{n})\to \Conid{C}\;\Varid{n}\;\Varid{e}\to \Conid{C}\;(\Varid{s}\;(\Varid{s}\;\Varid{n}))\;(\mathsf{evenSS}\;\Varid{n}\;\Varid{e}){}}
\nextline
\fromto{3}{8}{{}\Varid{n}{}}
\fromto{8}{E}{{}\mathrel{:}\Conid{Nat}{}}
\nextline
\fromto{3}{8}{{}\Varid{e}{}}
\fromto{8}{E}{{}\mathrel{:}\Conid{Even}\;\Varid{n}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    and the goal is
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\mathbin{?}\mathrel{:}\Conid{C}\;\Varid{n}\;\Varid{e}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    By eliminating \ensuremath{\Varid{e}} (using the non-indexed elimination) we get two cases

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{7}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{7}{{}\Varid{p}_{1}{}}
\fromto{7}{E}{{}\mathrel{:}\mathsf{z}==\Varid{n}{}}
\nextline
\fromto{3}{7}{{}\mathbin{?}{}}
\fromto{7}{E}{{}\mathrel{:}\Conid{C}\;\Varid{n}\;(\mathsf{evenZ}^{*}\;\Varid{p}_{1}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    Now we can eliminate \ensuremath{\Varid{p}_{1}}, effectively substituting \ensuremath{\Varid{z}} for \ensuremath{\Varid{n}} and \ensuremath{\mathsf{refl}}
    for \ensuremath{\Varid{p}_{1}} in the goal to obtain the new goal
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\mathbin{?}\mathrel{:}\Conid{C}\;\mathsf{z}\;(\mathsf{evenZ}^{*}\;\mathsf{refl}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    This is exactly the type of \ensuremath{\Varid{hz}}.

    In the second case we get
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{7}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{7}{{}\Varid{ih}{}}
\fromto{7}{E}{{}\mathrel{:}\Conid{C}\;\Varid{m}\;\Varid{e'}{}}
\nextline
\fromto{3}{7}{{}\Varid{p}_{2}{}}
\fromto{7}{E}{{}\mathrel{:}\mathsf{s}\;(\mathsf{s}\;\Varid{m})==\Varid{n}{}}
\nextline
\fromto{3}{7}{{}\mathbin{?}{}}
\fromto{7}{E}{{}\mathrel{:}\Conid{C}\;\Varid{n}\;(\mathsf{evenSS}^{*}\;\Varid{m}\;\Varid{e'}\;\Varid{p}_{2}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    Eliminating \ensuremath{\Varid{p}_{2}} yields
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\mathbin{?}\mathrel{:}\Conid{C}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{m}))\;(\mathsf{evenSS}^{*}\;\Varid{m}\;\Varid{e'}\;\mathsf{refl}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
    which is the type of
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{3}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{3}{E}{{}\Varid{hss}\;\Varid{m}\;\Varid{e'}\;\Varid{ih}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
Here is the elimination spelled out. To improve readability I present the
elimination of the interpretation using pattern matching notation and explicit
recursion.

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{5}{@{}l@{}}
\column{9}{@{}l@{}}
\column{17}{@{}l@{}}
\column{38}{@{}c@{}}
\column{38E}{@{}l@{}}
\column{43}{@{}c@{}}
\column{43E}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{5}{38}{{}elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;\Varid{n}\;(\mathsf{evenZ}^{*}\;\Varid{p}){}}
\fromto{38}{38E}{{}\mathrel{=}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{E}{{}\Varid{elim\char95 P}\;\mathsf{z}\;(\lambda \Varid{z}\;\Varid{q}.~\Conid{C}\;\mathsf{z}\;\mathsf{evenZ}^{*})\;\Varid{hz}\;\Varid{n}\;\Varid{p}{}}
\nextline
\fromto{5}{43}{{}elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;\Varid{n}\;(\mathsf{evenSS}^{*}\;\Varid{m}\;\Varid{e}\;\Varid{p}){}}
\fromto{43}{43E}{{}\mathrel{=}{}}
\nextline
\fromto{5}{9}{{}\hsindent{4}{}}
\fromto{9}{17}{{}\Varid{elim\char95 P}\;{}}
\fromto{17}{E}{{}(\mathsf{s}\;(\mathsf{s}\;\Varid{m}))\;{}}
\nextline
\fromto{17}{E}{{}(\lambda \Varid{z}\;\Varid{q}.~\Conid{C}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{m}))\;(\mathsf{evenSS}^{*}\;\Varid{e}))\;{}}
\nextline
\fromto{17}{E}{{}(\Varid{hss}\;\Varid{m}\;\Varid{e}\;(elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;\Varid{m}\;\Varid{e}))\;{}}
\nextline
\fromto{17}{E}{{}\Varid{n}\;\Varid{p}{}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

This gives us the correct type for the elimination rule, but we also need the
correct computation rules. Namely

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}l@{}}
\column{4}{@{}l@{}}
\column{29}{@{}l@{}}
\column{35}{@{}l@{}}
\column{49}{@{}l@{}}
\column{E}{@{}l@{}}
\fromto{B}{29}{{}elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;\mathsf{z}\;{}}
\fromto{29}{49}{{}\mathsf{evenZ}{}}
\fromto{49}{E}{{}\mathrel{=}\Varid{hz}{}}
\nextline
\fromto{B}{35}{{}elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;(\mathsf{s}\;(\mathsf{s}\;\Varid{n}))\;{}}
\fromto{35}{49}{{}(\mathsf{evenSS}\;\Varid{n}\;\Varid{e}){}}
\fromto{49}{E}{{}\mathrel{=}{}}
\nextline
\fromto{B}{4}{{}\hsindent{4}{}}
\fromto{4}{E}{{}\Varid{hss}\;\Varid{n}\;\Varid{e}\;(elim_{Even}\;\Conid{C}\;\Varid{hz}\;\Varid{hss}\;\Varid{n}\;\Varid{e}){}}
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks

The crucial point here is that the equations talk about \ensuremath{\mathsf{evenZ}} and \ensuremath{\mathsf{evenSS}\;\Varid{n}\;\Varid{e}} and not arbitrary elements of \ensuremath{\mathit{Even}^{*}\;\Varid{n}}. In these particular cases the proof
object is \ensuremath{\mathsf{refl}} so we can use the computation rule of equality elimination to
show the desired computation rules.

\subsection{Formal proof}

The proof is not fully formal. The main issue is that Agda is used both for the
meta level and the object level. This means that it is possible to mix up
object level reasoning and meta level reasoning in an unsound way. I take care
not to do this.

The proof is by (simple) induction over the code for the indexed type.

\section{Related Work}

Peter and Anton obviously~\cite{dybjer:indexed-ir}.

\section{Conclusions}

This is good stuff.

\bibliographystyle{abbrv}
\bibliography{../../../../bib/pmgrefs}

\end{document}