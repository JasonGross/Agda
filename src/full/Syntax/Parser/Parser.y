{
{-| The parser is generated by Happy (<http://www.haskell.org/happy>).
-}
module Syntax.Parser.Parser (
      tokensParser
    ) where

import Syntax.Position
import Syntax.Parser.Monad
import Syntax.Parser.Lexer
import Syntax.Parser.Tokens
import Syntax.Concrete

import Utils.Monad

}

%name tokensParser Tokens
%tokentype { Token }
%monad { Parser }
%lexer { lexer } { TokEOF }
-- %expect 3

%token
    'let'	{ TokKeyword KwLet $$ }
    'in'	{ TokKeyword KwIn $$ }
    'where'	{ TokKeyword KwWhere $$ }
    'postulate' { TokKeyword KwPostulate $$ }
    'open'	{ TokKeyword KwOpen $$ }
    'module'	{ TokKeyword KwModule $$ }
    'data'	{ TokKeyword KwData $$ }
    'infix'	{ TokKeyword KwInfix $$ }
    'infixl'	{ TokKeyword KwInfixL $$ }
    'infixr'	{ TokKeyword KwInfixR $$ }
    'mutual'	{ TokKeyword KwMutual $$ }
    'abstract'	{ TokKeyword KwAbstract $$ }
    'private'	{ TokKeyword KwPrivate $$ }
    'Prop'	{ TokKeyword KwProp $$ }
    'Set'	{ TokKeyword KwSet $$ }

    setN	{ TokSetN $$ }
    tex		{ TokTeX $$ }

    '.'		{ TokSymbol SymDot $$ }
    ','		{ TokSymbol SymComma $$ }
    ';'		{ TokSymbol SymSemi $$ }
    '`'		{ TokSymbol SymBackQuote $$ }
    ':'		{ TokSymbol SymColon $$ }
    '='		{ TokSymbol SymEqual $$ }
    '_'		{ TokSymbol SymUnderscore $$ }
    '?'		{ TokSymbol SymQuestionMark $$ }
    '->'	{ TokSymbol SymArrow $$ }
    '('		{ TokSymbol SymOpenParen $$ }
    ')'		{ TokSymbol SymCloseParen $$ }
    '['		{ TokSymbol SymOpenBracket $$ }
    ']'		{ TokSymbol SymCloseBracket $$ }
    '{'		{ TokSymbol SymOpenBrace $$ }
    '}'		{ TokSymbol SymCloseBrace $$ }
    vopen	{ TokSymbol SymOpenVirtualBrace $$ }
    vclose	{ TokSymbol SymCloseVirtualBrace $$ }
    vsemi	{ TokSymbol SymVirtualSemi $$ }

    id		{ TokId $$ }
    op		{ TokOp $$ }
    q_id	{ TokQId $$ }
    q_op	{ TokQOp $$ }

    int		{ TokLitInt $$ }
    float	{ TokLitFloat $$ }
    char	{ TokLitChar $$ }
    string	{ TokLitString $$ }

%%

{--------------------------------------------------------------------------
    Parsing the token stream. Used by the TeX compiler.
 --------------------------------------------------------------------------}

-- Parse a list of tokens.
Tokens : TokensR	{ reverse $1 }

-- Happy is much better at parsing left recursive grammars (constant
-- stack size vs. linear stack size for right recursive).
TokensR	: TokensR Token	{ $2 : $1 }
	|		{ [] }

-- Parse single token.
Token
    : 'let'	    { TokKeyword KwLet $1 }
    | 'in'	    { TokKeyword KwIn $1 }
    | 'where'	    { TokKeyword KwWhere $1 }
    | 'postulate'   { TokKeyword KwPostulate $1 }
    | 'open'	    { TokKeyword KwOpen $1 }
    | 'module'	    { TokKeyword KwModule $1 }
    | 'data'	    { TokKeyword KwData $1 }
    | 'infix'	    { TokKeyword KwInfix $1 }
    | 'infixl'	    { TokKeyword KwInfixL $1 }
    | 'infixr'	    { TokKeyword KwInfixR $1 }
    | 'mutual'	    { TokKeyword KwMutual $1 }
    | 'abstract'    { TokKeyword KwAbstract $1 }
    | 'private'	    { TokKeyword KwPrivate $1 }
    | 'Prop'	    { TokKeyword KwProp $1 }
    | 'Set'	    { TokKeyword KwSet $1 }

    | setN	    { TokSetN $1 }
    | tex	    { TokTeX $1 }

    | '.'	    { TokSymbol SymDot $1 }
    | ','	    { TokSymbol SymComma $1 }
    | ';'	    { TokSymbol SymSemi $1 }
    | '`'	    { TokSymbol SymBackQuote $1 }
    | ':'	    { TokSymbol SymColon $1 }
    | '='	    { TokSymbol SymEqual $1 }
    | '_'	    { TokSymbol SymUnderscore $1 }
    | '?'	    { TokSymbol SymQuestionMark $1 }
    | '->'	    { TokSymbol SymArrow $1 }
    | '('	    { TokSymbol SymOpenParen $1 }
    | ')'	    { TokSymbol SymCloseParen $1 }
    | '['	    { TokSymbol SymOpenBracket $1 }
    | ']'	    { TokSymbol SymCloseBracket $1 }
    | '{'	    { TokSymbol SymOpenBrace $1 }
    | '}'	    { TokSymbol SymCloseBrace $1 }
    | vopen	    { TokSymbol SymOpenVirtualBrace $1 }
    | vclose	    { TokSymbol SymCloseVirtualBrace $1 }
    | vsemi	    { TokSymbol SymVirtualSemi $1 }

    | id	    { TokId $1 }
    | op	    { TokOp $1 }
    | q_id	    { TokQId $1 }
    | q_op	    { TokQOp $1 }

    | int	    { TokLitInt $1 }
    | float	    { TokLitFloat $1 }
    | char	    { TokLitChar $1 }
    | string	    { TokLitString $1 }

{--------------------------------------------------------------------------
    Meta rules
 --------------------------------------------------------------------------}

-- The first token in a file decides the indentation of the top
-- level layout block.
topen :	{- empty -}	{% pushCurrentContext }


{-  A layout block might have to be closed by a parse error. Example:
	let x = e in e'
    Here the 'let' starts a layout block which should end before the 'in'.  The
    problem is that the lexer doesn't know this, so there is no virtual close
    brace. However when the parser sees the 'in' there will be a parse error.
    This is our cue to close the layout block.
-}
close : vclose	{ () }
      | error	{% popContext }


-- You can use concrete semi colons in a layout block started with a virtual
-- brace, so we don't have to distinguish between the two semi colons. You can't
-- use a virtual semi colon in a block started by a concrete brace, but this is
-- simply because the lexer will not generate virtual semis in this case.
semi : ';'	{ $1 }
     | vsemi	{ $1 }


{--------------------------------------------------------------------------
    Helper rules
 --------------------------------------------------------------------------}

-- Unqualifed identifiers. This is something that could appear in a binding
-- position.
Id  : id	    { $1 }
    | '(' op ')'    { $2 }

-- Qualified operators are treated as identifiers, i.e. they have to be back
-- quoted to appear infix.
QId : q_id	    { $1 }
    | q_op	    { $1 }
    | Id	    { QName [] $1 }

-- Infix operator. All names except unqualified operators have to be back
-- quoted.
Op  : op	    { QName [] $1 }
    | '`' id '`'    { QName [] $2 }
    | '`' q_id '`'  { $2 }
    | '`' q_op '`'  { $2 }

-- An unqualified name (identifier or operator). This is what you write in
-- import lists.
Name : id   { $1 }
     | op   { $1 }

{-
import Ring, using (sum, +, *), renaming (product to foo)
namespace NatRing = Ring Nat (+) 0, hiding (sum)
open NatRing, renaming (product to prod', * to times)
-}

{

-- | Parse the token stream. Used by the TeX compiler.
tokensParser	:: Parser [Token]

-- | Required by Happy.
happyError :: Parser a
happyError = parseError "Parse error"

}
