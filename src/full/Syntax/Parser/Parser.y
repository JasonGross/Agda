{
{-| The parser is generated by Happy (<http://www.haskell.org/happy>).
-}
module Syntax.Parser.Parser (
      exprParser
    , tokensParser
    ) where

import Syntax.Position
import Syntax.Parser.Monad
import Syntax.Parser.Lexer
import Syntax.Parser.Tokens
import Syntax.Concrete
import Syntax.Common

import Utils.Monad

}

%name tokensParser Tokens
%name exprParser Expr
%tokentype { Token }
%monad { Parser }
%lexer { lexer } { TokEOF }

-- This is a trick to get rid of shift/reduce conflicts arising because we want
-- to parse things like "m >>= \x -> k x". See the Expr rule for more
-- information.
%nonassoc LOWEST
%nonassoc '`' '->' op

%token
    'let'	{ TokKeyword KwLet $$ }
    'in'	{ TokKeyword KwIn $$ }
    'where'	{ TokKeyword KwWhere $$ }
    'postulate' { TokKeyword KwPostulate $$ }
    'open'	{ TokKeyword KwOpen $$ }
    'module'	{ TokKeyword KwModule $$ }
    'data'	{ TokKeyword KwData $$ }
    'infix'	{ TokKeyword KwInfix $$ }
    'infixl'	{ TokKeyword KwInfixL $$ }
    'infixr'	{ TokKeyword KwInfixR $$ }
    'mutual'	{ TokKeyword KwMutual $$ }
    'abstract'	{ TokKeyword KwAbstract $$ }
    'private'	{ TokKeyword KwPrivate $$ }
    'Prop'	{ TokKeyword KwProp $$ }
    'Set'	{ TokKeyword KwSet $$ }

    setN	{ TokSetN $$ }
    tex		{ TokTeX $$ }

    '.'		{ TokSymbol SymDot $$ }
    ','		{ TokSymbol SymComma $$ }
    ';'		{ TokSymbol SymSemi $$ }
    '`'		{ TokSymbol SymBackQuote $$ }
    ':'		{ TokSymbol SymColon $$ }
    '='		{ TokSymbol SymEqual $$ }
    '_'		{ TokSymbol SymUnderscore $$ }
    '?'		{ TokSymbol SymQuestionMark $$ }
    '->'	{ TokSymbol SymArrow $$ }
    '\\'	{ TokSymbol SymLambda $$ }
    '('		{ TokSymbol SymOpenParen $$ }
    ')'		{ TokSymbol SymCloseParen $$ }
    '['		{ TokSymbol SymOpenBracket $$ }
    ']'		{ TokSymbol SymCloseBracket $$ }
    '{'		{ TokSymbol SymOpenBrace $$ }
    '}'		{ TokSymbol SymCloseBrace $$ }
    vopen	{ TokSymbol SymOpenVirtualBrace $$ }
    vclose	{ TokSymbol SymCloseVirtualBrace $$ }
    vsemi	{ TokSymbol SymVirtualSemi $$ }

    id		{ TokId $$ }
    op		{ TokOp $$ }
    q_id	{ TokQId $$ }
    q_op	{ TokQOp $$ }

    literal	{ TokLiteral $$ }

%%

{--------------------------------------------------------------------------
    Parsing the token stream. Used by the TeX compiler.
 --------------------------------------------------------------------------}

-- Parse a list of tokens.
Tokens :: { [Token] }
Tokens : TokensR	{ reverse $1 }

-- Happy is much better at parsing left recursive grammars (constant
-- stack size vs. linear stack size for right recursive).
TokensR :: { [Token] }
TokensR	: TokensR Token	{ $2 : $1 }
	|		{ [] }

-- Parse single token.
Token :: { Token }
Token
    : 'let'	    { TokKeyword KwLet $1 }
    | 'in'	    { TokKeyword KwIn $1 }
    | 'where'	    { TokKeyword KwWhere $1 }
    | 'postulate'   { TokKeyword KwPostulate $1 }
    | 'open'	    { TokKeyword KwOpen $1 }
    | 'module'	    { TokKeyword KwModule $1 }
    | 'data'	    { TokKeyword KwData $1 }
    | 'infix'	    { TokKeyword KwInfix $1 }
    | 'infixl'	    { TokKeyword KwInfixL $1 }
    | 'infixr'	    { TokKeyword KwInfixR $1 }
    | 'mutual'	    { TokKeyword KwMutual $1 }
    | 'abstract'    { TokKeyword KwAbstract $1 }
    | 'private'	    { TokKeyword KwPrivate $1 }
    | 'Prop'	    { TokKeyword KwProp $1 }
    | 'Set'	    { TokKeyword KwSet $1 }

    | setN	    { TokSetN $1 }
    | tex	    { TokTeX $1 }

    | '.'	    { TokSymbol SymDot $1 }
    | ','	    { TokSymbol SymComma $1 }
    | ';'	    { TokSymbol SymSemi $1 }
    | '`'	    { TokSymbol SymBackQuote $1 }
    | ':'	    { TokSymbol SymColon $1 }
    | '='	    { TokSymbol SymEqual $1 }
    | '_'	    { TokSymbol SymUnderscore $1 }
    | '?'	    { TokSymbol SymQuestionMark $1 }
    | '->'	    { TokSymbol SymArrow $1 }
    | '\\'	    { TokSymbol SymLambda $1 }
    | '('	    { TokSymbol SymOpenParen $1 }
    | ')'	    { TokSymbol SymCloseParen $1 }
    | '['	    { TokSymbol SymOpenBracket $1 }
    | ']'	    { TokSymbol SymCloseBracket $1 }
    | '{'	    { TokSymbol SymOpenBrace $1 }
    | '}'	    { TokSymbol SymCloseBrace $1 }
    | vopen	    { TokSymbol SymOpenVirtualBrace $1 }
    | vclose	    { TokSymbol SymCloseVirtualBrace $1 }
    | vsemi	    { TokSymbol SymVirtualSemi $1 }

    | id	    { TokId $1 }
    | op	    { TokOp $1 }
    | q_id	    { TokQId $1 }
    | q_op	    { TokQOp $1 }

    | literal	    { TokLiteral $1 }

{--------------------------------------------------------------------------
    Meta rules
 --------------------------------------------------------------------------}

-- The first token in a file decides the indentation of the top
-- level layout block.
topen :	{- empty -}	{% pushCurrentContext }


{-  A layout block might have to be closed by a parse error. Example:
	let x = e in e'
    Here the 'let' starts a layout block which should end before the 'in'.  The
    problem is that the lexer doesn't know this, so there is no virtual close
    brace. However when the parser sees the 'in' there will be a parse error.
    This is our cue to close the layout block.
-}
close : vclose	{ () }
      | error	{% popContext }


-- You can use concrete semi colons in a layout block started with a virtual
-- brace, so we don't have to distinguish between the two semi colons. You can't
-- use a virtual semi colon in a block started by a concrete brace, but this is
-- simply because the lexer will not generate virtual semis in this case.
semi : ';'	{ $1 }
     | vsemi	{ $1 }


{--------------------------------------------------------------------------
    Names
 --------------------------------------------------------------------------}

-- Unqualifed identifiers. This is something that could appear in a binding
-- position.
Id :: { Name }
Id  : id	    { $1 }
    | '(' op ')'    { $2 }


-- Qualified operators are treated as identifiers, i.e. they have to be back
-- quoted to appear infix.
QId :: { QName }
QId : q_id	    { $1 }
    | q_op	    { $1 }
    | Id	    { QName [] $1 }


-- Infix operator. All names except unqualified operators have to be back
-- quoted.
Op :: { QName }
Op  : op	    { QName [] $1 }
    | '`' id '`'    { QName [] $2 }
    | '`' q_id '`'  { $2 }
    | '`' q_op '`'  { $2 }


-- An unqualified name (identifier or operator). This is what you write in
-- import lists.
Name :: { Name }
Name : id   { $1 }
     | op   { $1 }


-- A comma separated list of unqualified identifiers. Used in dependent
-- function spaces: (x,y,z : Nat) -> ...
CommaIds :: { [Name] }
CommaIds
    : Id ',' CommaIds	{ $1 : $3 }
    | Id		{ [$1] }

{--------------------------------------------------------------------------
    Expressions (terms and types)
 --------------------------------------------------------------------------}

{-  Expressions. You might expect lambdas and lets to appear in the first
    expression category (lowest precedence). The reason they don't is that we
    wan't to parse things like

	m >>= \x -> k x

    This will leads to a conflict in the following case

	m >>= \x -> k x >>= \y -> k' y

    At the second '>>=' we can either shift or reduce. We solve this problem
    using Happy's precedence directives. The rule 'Expr -> Expr1' (which is the
    rule you shouldn't use to reduce when seeing '>>=') is given LOWEST
    precedence.  The terminals '`' '->' and op (which is what you should shift)
    is given higher precedence.
-}

-- Top level: Function types.
Expr :: { Expr }
Expr
    : TypedBinding '->' Expr	{ Pi $1 $3 }
    | '{' Expr '}' '->' Expr	{ Fun (fuseRange $1 $5) Hidden $2 $5 }
    | Expr1 '->' Expr		{ Fun (fuseRange $1 $3) NotHidden $1 $3 }
    | Expr1 %prec LOWEST	{ $1 }


-- Level 1: Infix operators
Expr1
    : Expr1 Op Expr2		{ InfixApp $1 $2 $3 }
    | Expr2			{ $1 }


-- Level 2: Lambdas and lets
Expr2
    : '\\' LamBindings '->' Expr	{ Lam (fuseRange $1 $4) $2 $4 }
    | 'let' LocalDefinitions 'in' Expr	{ Let (fuseRange $1 $4) $2 $4 }
    | Expr3				{ $1 }


-- Level 3: Application
Expr3
    : Expr3 Expr4	    { App (fuseRange $1 $2) NotHidden $1 $2 }
    | Expr3 '{' Expr '}'    { App (fuseRange $1 $4) Hidden $1 $3 }
    | Expr4		    { $1 }


-- Level 4: Atoms
Expr4
    : QId		{ Ident $1 }
    | literal		{ Lit $1 }
    | '?'		{ QuestionMark $1 }
    | '_'		{ Underscore $1 }
    | 'Prop'		{ Prop $1 }
    | 'Set'		{ Set $1 }
    | setN		{ uncurry SetN $1 }
    | '(' Expr ')'	{ Paren (fuseRange $1 $3) $2 }


{--------------------------------------------------------------------------
    Bindings
 --------------------------------------------------------------------------}

-- A telescope is a non-empty sequence of typed bindings.
Telescope :: { Telescope }
Telescope
    : TypedBinding Telescope	{ $1 : $2 }
    | TypedBinding		{ [$1] }


-- A typed binding is either (x1,..,xn:A) or {x1,..,xn:A}.
TypedBinding :: { TypedBinding }
TypedBinding
    : '(' CommaIds ':' Expr ')'
			    { TypedBinding (fuseRange $1 $5) NotHidden $2 $4 }
    | '{' CommaIds ':' Expr '}'
			    { TypedBinding (fuseRange $1 $5) Hidden $2 $4 }


-- A non-empty sequence of lambda bindings. For purely aestethical reasons we
-- disallow mixing typed and untyped bindings in lambdas.
LamBindings :: { [LamBinding] }
LamBindings
    : Telescope		    { map DomainFull $1 }
    | DomainFreeBindings    { $1 }


-- A non-empty sequence of domain-free bindings
DomainFreeBindings :: { [LamBinding] }
DomainFreeBindings
    : DomainFreeBinding DomainFreeBindings  { $1 : $2 }
    | DomainFreeBinding			    { [$1] }


-- A domain free binding is either x or {x}
DomainFreeBinding :: { LamBinding }
DomainFreeBinding
    : Id	    { DomainFree NotHidden $1 }
    | '{' Id '}'    { DomainFree Hidden $2 }


{--------------------------------------------------------------------------
    Definitions
 --------------------------------------------------------------------------}

-- Sequences of local definitions are controlled by layout.  To improve Happy
-- performance we parse the lists left recursively, which means we have to
-- reverse the list in the end.
LocalDefinitions :: { [LocalDefinition] }
LocalDefinitions
    : '{' LocalDefinitions1 '}'	    { reverse $2 }
    | vopen LocalDefinitions1 close { reverse $2 }


-- Inside the layout block. Definition lists have to be non-empty.
LocalDefinitions1 :: { [LocalDefinition] }
LocalDefinitions1
    : LocalDefinitions1 semi LocalDefinition	{ $3 : $1 }
    | LocalDefinition				{ [$1] }


{-  Local definition. The arguments to 'Definition' indicate which subfamily a
    definition belongs to. In this case we generate definitions in a subfamily
    where we don't care whether we are type signatures (first DontCare) or
    whether we can appear in a private block (second DontCare). The definitions
    are polymorphic in whether the can appear in a local definition (meaning
    that they can).
-}
LocalDefinition :: { Definition DontCare local DontCare }
LocalDefinition
    : TypeSig			    { $1 }
    | Expr '=' Expr WhereClause	    { FunClause $1 $3 $4 }


-- Type signature
TypeSig :: { Definition typesig local private }
TypeSig : Id ':' Expr   { TypeSig $1 $3 }


-- Where clauses are optional
WhereClause :: { WhereClause }
WhereClause
    : {- empty -}		{ [] }
    | 'where' LocalDefinitions	{ $2 }

{

-- | Parse the token stream. Used by the TeX compiler.
tokensParser :: Parser [Token]

-- | Parse an expression. Could be used in interactions.
exprParser :: Parser Expr

-- | Required by Happy.
happyError :: Parser a
happyError = parseError "Parse error"

}
