{
module Syntax.Parser.Lexer
    ( -- * The main function
      lexer
      -- * Lex states
    , normal, literate
    , layout, empty_layout, bol
      -- * Alex generated functions
    , AlexReturn(..), alexScan
    ) where

import Data.List
import Data.Char

import Syntax.Parser.Alex
import Syntax.Parser.Comments
import Syntax.Parser.Layout
import Syntax.Parser.LexActions
import Syntax.Parser.Monad
import Syntax.Parser.StringLiterals
import Syntax.Parser.Tokens
import Syntax.Position

import Utils.Unicode (isUnicodeId, isUnicodeOp)

}

$digit	    = 0-9
$idstart    = [ A-Z a-z ]
$alphanum   = [ $idstart $digit _ ' ]
$sym	    = [ \!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\~\: ]
$symstart   = [ \- $sym ]
$notdash    = [ ' $sym ]
$symbol	    = [ \- ' $sym ]

$white_nonl = $white # \n

tokens :-

<tex>	 ^ \\ "begin{code}" \n	{ begin_ code }
<tex>	 ^ .* \n		{ withRange $ TkTeX . snd }
<tex>	 ^ .+			{ withRange $ TkTeX . snd }
<code>   ^ \\ "end{code}" \n	{ end_ }

<0,code,bol_,layout_,empty_layout_>
    $white_nonl+    ;

<0,code,bol_,layout_,empty_layout_>
    "{-"	    { nestedComment }

-- Dashes followed by an operator symbol should be parsed as an operator.
<0,code,bol_,layout_,empty_layout_>   "--"\-* [^$symbol] .* ;
<0,code,bol_,layout_,empty_layout_>   "--"\-* $		    ;
<0,code> \n	{ begin bol_ }
<bol_>
    {
	\n	;
	()	{ offsideRule }
    }
<layout_>
    {	\n	;
	\{	{ endWith openBrace }
	()	{ endWith newLayoutContext }
    }
<empty_layout_> ()		{ emptyLayout }

<0,code> Set			{ withRange_ TkSet }
<0,code> Prop			{ withRange_ TkProp }
<0,code> Type			{ withRange_ TkType }
<0,code> data			{ withRange_ TkData }
<0,code> where			{ withLayout $ withRange_ TkWhere }
<0,code> of			{ withLayout $ withRange_ TkOf }
<0,code> let			{ withLayout $ withRange_ TkLet }
<0,code> sig			{ withLayout $ withRange_ TkSig }
<0,code> struct			{ withLayout $ withRange_ TkStruct }
<0,code> in			{ withRange_ TkIn }
<0,code> infix			{ withRange_ TkInfix }
<0,code> infixl			{ withRange_ TkInfixL }
<0,code> infixr			{ withRange_ TkInfixR }
<0,code> $idstart $alphanum* \- plugin
				{ withRange' (takeWhile ('-'/=)) TkPlugin }
<0,code> $idstart $alphanum*	{ withRange TkId }
<0,code> \_ $alphanum+		{ withRange TkId }
<0,code> $digit+		{ withRange' read TkInt }
<0,code> \_			{ withRange_ TkUnderscore }    
<0,code> \#$digit+		{ withRange' (read . tail) TkUniverse }
<0,code> \(			{ withRange_ TkLParen }
<0,code> \)			{ withRange_ TkRParen }
<0,code> \\			{ withRange_ TkLambda }
<0,code> \-\>			{ withRange_ TkArrow }
<0,code> \,			{ withRange_ TkComma }
<0,code> \;			{ withRange_ TkSemi }
<0,code> \:			{ withRange_ TkColon }
<0,code> \=\>			{ withRange_ TkDblArrow }
<0,code> \=			{ withRange_ TkEqual }
<0,code> \.			{ withRange_ TkDot }
<0,code> \`			{ withRange_ TkBackQuote }
<0,code> \{			{ openBrace }
<0,code> \}			{ closeBrace }
<0,code> \[			{ withRange_ TkOpenSquare }
<0,code> \]			{ withRange_ TkCloseSquare }
<0,code> $symstart $symbol*	{ withRange TkOp }
<0,code> \"			{ litString }
<0,code> \'			{ litChar }

{

-- | This is the initial state for parsing a literate file. Code blocks
--   should be enclosed in @\\begin{code}@ @\\end{code}@ pairs.
literate :: LexState
literate = tex

-- | This is the initial state for parsing a regular, non-literate file.
normal :: LexState
normal = 0

{-| The layout state. Entered when we see a layout keyword ('withLayout') and
    exited either when seeing an open brace ('openBrace') or at the next token
    ('newLayoutContext').
-}
layout :: LexState
layout = layout_

{-| We enter this state from 'newLayoutContext' when the token following a
    layout keyword is to the left of (or at the same column as) the current
    layout context. Example:

    > data Empty : Set where
    > foo : Empty -> Nat

    Here the second line is not part of the @where@ clause since it is has the
    same indentation as the @data@ definition. What we have to do is insert an
    empty layout block @{}@ after the @where@. The only thing that can happen
    in this state is that 'emptyLayout' is executed, generating the closing
    brace. The open brace is generated when entering by 'newLayoutContext'.
-}
empty_layout :: LexState
empty_layout = empty_layout_

-- | This state is entered at the beginning of each line. You can't lex
--   anything in this state, and to exit you have to check the layout rule.
--   Done with 'offsideRule'.
bol :: LexState
bol = bol_

-- | Return the next token. This is the function used by Happy in the parser.
--
--   @lexer k = 'lexToken' >>= k@
lexer :: (Token -> Parser a) -> Parser a
lexer k = lexToken >>= k

-- | This is main lexing function generated by Alex.
alexScan :: AlexInput -> Int -> AlexReturn (LexAction Token)

}
