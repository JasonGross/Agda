{
module Syntax.Parser.Lexer
    ( lexer
    , normal, literate
    , layout, bol
    , AlexReturn(..), alexScan
    ) where

import Data.List
import Data.Char

import Syntax.Parser.Alex
import Syntax.Parser.Layout
import Syntax.Parser.LexActions
import Syntax.Parser.Monad
import Syntax.Parser.StringLiterals
import Syntax.Parser.Tokens
import Syntax.Position

import Utils.Unicode (isUnicodeId, isUnicodeOp)

}

$digit	    = 0-9
$idstart    = [ A-Z a-z ]
$alphanum   = [ $idstart $digit _ ' ]
$sym	    = [ \!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\~\: ]
$symstart   = [ \- $sym ]
$notdash    = [ ' $sym ]
$symbol	    = [ \- ' $sym ]

$white_nonl = $white # \n

tokens :-

<tex>	 ^ \\ "begin{code}" \n	{ begin_ code }
<tex>	 ^ .* \n		{ withRange $ \_ -> TkTeX }
<tex>	 ^ .+			{ withRange $ \_ -> TkTeX }
<code>   ^ \\ "end{code}" \n	{ end_ }

<0,code,bol,layout,layout_left>
    $white_nonl+	;

<0,code,bol,layout,layout_left>
    "{-"		{ nestedComment }

-- Dashes followed by an operator symbol should be parsed as an operator.
<0,code,bol,layout,layout_left>
    "--"\-* [^$notdash] .*   ;
<0,code,bol,layout,layout_left>
    "--"\-* / { atEOL }	    ;
<0,code> \n		{ begin bol }
<bol>
    {
	\n		;
	()		{ beginningOfLine }
    }
<layout>
    {	\{ / { notFollowedBy '-' }  { endWith openBrace }
	\n			    ;
	()			    { newLayoutContext }
    }
<layout_left> ()		{ layoutLeft }

<0,code> Star \+ $digit+	{ withRange tkStar }
<0,code> Star			{ withRange tkStar }
<0,code> ISet			{ withRange_ TkISet }
<0,code> Set			{ withRange_ TkSet }
<0,code> Prop			{ withRange_ TkProp }
<0,code> Type			{ withRange_ TkType }
<0,code> data			{ withRange_ TkData }
<0,code> where			{ withLayout $ withRange_ TkWhere }
<0,code> of			{ withLayout $ withRange_ TkOf }
<0,code> let			{ withLayout $ withRange_ TkLet }
<0,code> sig			{ withLayout $ withRange_ TkSig }
<0,code> struct			{ withLayout $ withRange_ TkStruct }
<0,code> in			{ withRange_ TkIn }
<0,code> infix			{ withRange_ TkInfix }
<0,code> infixl			{ withRange_ TkInfixL }
<0,code> infixr			{ withRange_ TkInfixR }
<0,code> $idstart $alphanum* \- plugin
				{ withRange $ \r s -> TkPlugin (r, takeWhile ('-'/=) s) }
<0,code> $idstart $alphanum*	{ withRange (curry TkId) }
<0,code> \_ $alphanum+		{ withRange (curry TkId) }
<0,code> $digit+		{ withRange $ \r s -> TkInt (r,read s) }
<0,code> \_			{ withRange_ TkUnderscore }    
<0,code> \#$digit+		{ withRange $ \r s -> TkUniverse (r, read (tail s)) }
<0,code> \(			{ withRange_ TkLParen }
<0,code> \)			{ withRange_ TkRParen }
<0,code> \\			{ withRange_ TkLambda }
<0,code> \-\>			{ withRange_ TkArrow }
<0,code> \,			{ withRange_ TkComma }
<0,code> \;			{ withRange_ TkSemi }
<0,code> \:			{ withRange_ TkColon }
<0,code> \=\>			{ withRange_ TkDblArrow }
<0,code> \=			{ withRange_ TkEqual }
<0,code> \.			{ withRange_ TkDot }
<0,code> \`			{ withRange_ TkBackQuote }
<0,code> \{			{ openBrace }
<0,code> \}			{ closeBrace }
<0,code> \[			{ withRange_ TkOpenSquare }
<0,code> \]			{ withRange_ TkCloseSquare }
<0,code> $symstart $symbol*	{ withRange (curry TkOp) }
<0,code> \"			{ lex_atom }

{

-- | This is the initial state for parsing a literate file. Code blocks
--   should be enclosed in @\\begin{code}@-@\\end{code}@ pairs.
literate :: LexState
literate = tex

-- | This is the initial state for parsing a regular, non-literate file.
normal :: LexState
normal = 0

-- | The layout state. Entered when we see a layout keywork. See 'withLayout'.
layout :: LexState

-- | This state is entered at the beginning of each line. You can't lex
--   anything in this state, and to exit you have to check the layout rule.
--   Done with 'beginningOfLine'.
bol :: LexState

-- | Lex a single token. This is the function Happy is using.
--
--   @lexer k = 'scanToken' >>= k@
lexer :: (Token -> Parser a) -> Parser a
lexer k = scanToken >>= k

-- | This is main lexing function generated by Alex.
alexScan :: AlexInput -> Int -> AlexReturn (LexAction Token)

}
