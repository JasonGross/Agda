------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.3.4
------------------------------------------------------------------------

Important changes since 2.3.2:

Installation
============

Pragmas and Options
===================

* Pragma NO_TERMINATION_CHECK placed within a mutual block is now
  applied to the whole mutual block (rather than being discarded
  silently).  Adding to the uses 1.-4. outlined in the release notes
  for 2.3.2 we allow:

  3a. Skipping an old-style mutual block: Somewhere within 'mutual'
      block before a type signature or first function clause.

       mutual
         {-# NO_TERMINATION_CHECK #-}
         c : A
         c = d

         d : A
         d = c

Language
========

* Function clauses may now have different arity, e.g.,

    Sum : ℕ → Set
    Sum 0       = ℕ
    Sum (suc n) = ℕ → Sum n

    sum : (n : ℕ) → ℕ → Sum n
    sum 0       acc   = acc
    sum (suc n) acc m = sum n (m + acc)

  or,

    T : Bool → Set
    T true  = Bool
    T false = Bool → Bool

    f : (b : Bool) → T b
    f false true  = false
    f false false = true
    f true = true

* Ambiguous names in patterns are now optimistically resolved in favor
  of constructors. [Issue 822] In particular, the following succeeds now:

    module M where

      data D : Set₁ where
        [_] : Set → D

    postulate [_] : Set → Set

    open M

    Foo : _ → Set
    Foo [ A ] = A

* Anonymous where-modules are opened public. [Issue 848]

    <clauses>
    f args = rhs
      module _ telescope where
        body
    <more clauses>

  means the following (not proper Agda code, since you cannot put a
  module in-between clauses)

    <clauses>
    module _ {arg-telescope} telescope where
      body

    f args = rhs
    <more clauses>

  Example:

    A : Set1
    A = B module _ where
      B : Set1
      B = Set

    C : Set1
    C = B


Goal and error display
======================

* The error message "Refuse to construct infinite term" has been
  removed, instead one gets unsolved meta variables.  Reason: the
  error was thrown over-eagerly. [Issue 795]

* If an interactive case split fails with message

    Since goal is solved, further case distinction is not supported;
    try `Solve constraints' instead

  then the associated interaction meta is assigned to a solution.
  Press C-c C-= (Show constraints) to view the solution and C-c C-s
  (Solve constraints) to apply it. [Issue 289]

Type checking
=============

* A buggy facility coined "matrix-shaped orders" that supported
  uncurried functions (which take tuples of arguments instead of one
  argument after another) has been removed from the termination
  checker. [Issue 787]

* Definitions which fail the termination checker are not unfolded any
  longer to avoid loops or stack overflows in Agda.  However, the
  termination checker for a mutual block is only invoked after
  type-checking, so there can still be loops if you define a
  non-terminating function.  But termination checking now happens
  before the other supplementary checks: positivity, polarity,
  injectivity and projection-likeness.
  Note that with the pragma {-# NO_TERMINATION_CHECK #-} you can make
  Agda treat any function as terminating.

* Implicit patterns of record type are now only eta-expanded if there
  is a record constructor. [Issues 473, 635]

    data D : Set where
      d : D

    data P : D → Set where
      p : P d

    record Rc : Set where
      constructor c
      field f : D

    works : {r : Rc} → P (Rc.f r) → Set
    works p = D

  This works since the implicit pattern {r} is eta-expanded to
  {c x} which allows the type of p to reduce to P x and x to be
  unified with d.  The corresponding explicit version is:

    works' : (r : Rc) → P (Rc.f r) → Set
    works' (c .d) p = D

  However, if the record constructor is removed, the same example will
  fail:

    record R : Set where
      field f : D

    fails : {r : R} → P (R.f r) → Set
    fails p = D

    -- d != R.f r of type D
    -- when checking that the pattern p has type P (R.f r)

  The error is justified since there is no pattern we could write down
  for r.  It would have to look like

    record { f = .d }

  but anonymous record patterns are not part of the language.

* Absurd lambdas at different source locations are no longer
  different. [Issue 857]
  In particular, the following code type-checks now:

    absurd-equality : _≡_ {A = ⊥ → ⊥} (λ()) λ()
    absurd-equality = refl

  Which is a good thing!

* --without-K is less restrictive. [Issue 712]
  The handling of parameters differs from Agda 2.3.2 as follows:

  1. Parameters that occur in constructor indices are classified as
     `non-linear' and treated just as indices.

  2. Parameters that are linear (i.e, fail 1.) and `big', i.e.,

     a) levels or
     b) type arguments of equal size (universe level) as the data type

     are disregarded by the analysis.

  New specification of --without-K:

  If the flag is activated, then Agda only accepts certain
  case-splits. If the type of the variable to be split is D ts,
  where D is a data (or record) type, pars stands for the small
  parameters among ts, and ixs the indices among ts (including
  non-linear parameters), then the following requirements must be
  satisfied:

  * The indices ixs must be applications of constructors (or literals)
    to distinct variables. Constructors are usually not applied to
    parameters, but for the purposes of this check constructor
    small parameters are treated as other arguments.  Big parameters
    and levels are ignored.

  * These distinct variables must not be free in pars.

  Examples:

  * List type.

      data List {a} (A : Set a) : Set a where
        []  : List A
        _∷_ : (x : A) (xs : List A) → List A

    Parameter a is considered big since it is a level.
    A is considered big because its level (a) is not strictly below
    the level of the data type (also a).

  * Small parameter.

      data D {A : Set} (f : Unit → A) : A → Set where
        d : ∀ {x} → D f x

    A is big, f is small.  This means that f will be considered as
    constructor argument, just like x, (but not as index).

  * Equality type.

      data _≡_ {A : Set} (x : A) : A → Set where
        refl : x ≡ x

    Parameter A is big.  x is non-linear, because it occurs in the
    index in constructor refl.

  * Big versus non-linear:

      data _≡_ (A : Set) : Set → Set where
        refl : A ≡ A

    The parameter A is non-linear and treated as index.


Compiler backends
=================

Tools
=====

Emacs mode
----------

* Key bindings for lots of "mathematical" characters (examples: 𝐴𝑨𝒜𝓐𝔄)
  have been added to the Agda input method.

* Key bindings for "blackboard bold" B (𝔹) and 0-9 (𝟘-𝟡) have been added
  to the Agda input method (\bb and \b[0-9]).

* Key bindings for controlling simplification/normalisation:

  [TODO: Simplification should be explained somewhere.]

  Commands like "Goal type and context" (C-c C-,) could previously be
  invoked in two ways. By default the output was normalised, but if a
  prefix argument was used (for instance via C-u C-c C-,), then no
  explicit normalisation was performed. Now there are three options:

  * By default (C-c C-,) the output is simplified.

  * If C-u is used exactly once (C-u C-c C-,), then the result is
    neither (explicitly) normalised nor simplified.

  * If C-u is used twice (C-u C-u C-c C-,), then the result is
    normalised.

  [TODO: As part of the release of Agda 2.3.4 the key binding page on
  the wiki should be updated.]

LaTeX-backend
-------------

* Two new color scheme options were added to agda.sty:

  \usepackage[bw]{agda}, which highlights in black and white;
  \usepackage[conor]{agda}, which highlights using Conor's colors.

  The default (no options passed) is to use the standard colors.

* If agda.sty cannot be found by the latex environment, it is now
  copied into the latex output directory ('latex' by default) instead
  of the working directory. This means that the commands needed to
  produce a PDF now is

    agda --latex -i . <file>.lagda
    cd latex
    pdflatex <file>.tex
