------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.3.4
------------------------------------------------------------------------

Important changes since 2.3.2:

Installation
============

Pragmas and Options
===================

* Pragma NO_TERMINATION_CHECK placed within a mutual block is now
  applied to the whole mutual block (rather than being discarded
  silently).  Adding to the uses 1.-4. outlined in the release notes
  for 2.3.2 we allow:

  3a. Skipping an old-style mutual block: Somewhere within 'mutual'
      block before a type signature or first function clause.

       mutual
         {-# NO_TERMINATION_CHECK #-}
         c : A
         c = d

         d : A
         d = c

Language
========

* Experimental feature: Varying arity.
  Function clauses may now have different arity, e.g.,

    Sum : ℕ → Set
    Sum 0       = ℕ
    Sum (suc n) = ℕ → Sum n

    sum : (n : ℕ) → ℕ → Sum n
    sum 0       acc   = acc
    sum (suc n) acc m = sum n (m + acc)

  or,

    T : Bool → Set
    T true  = Bool
    T false = Bool → Bool

    f : (b : Bool) → T b
    f false true  = false
    f false false = true
    f true = true

  This feature is experimental.  Yet unsupported:
  * Varying arity and 'with'.
  * Compilation of functions with varying arity to Haskell, JS, or Epic.

* Experimental feature: copatterns.  (Activated with option --copatterns)

  We can now define a record by explaining what happens if you project
  the record.  For instance:

    {-# OPTIONS --copatterns #-}

    record _×_ (A B : Set) : Set where
      constructor _,_
      field
        fst : A
        snd : B
    open _×_

    pair : {A B : Set} → A → B → A × B
    fst (pair a b) = a
    snd (pair a b) = b

    swap : {A B : Set} → A × B → B × A
    fst (swap p) = snd p
    snd (swap p) = fst p

    swap3 : {A B C : Set} → A × (B × C) → C × (B × A)
    fst (swap3 t)       = snd (snd t)
    fst (snd (swap3 t)) = fst (snd t)
    snd (snd (swap3 t)) = fst t

  Taking a projection on the left hand side (lhs) is called a
  projection pattern, applying to a pattern is called an application
  pattern.  (Alternative terms: projection/application copattern.)

  In the first example, the symbol 'pair', if applied to variable
  patterns a and b and then projected via fst, reduces to a.
  'pair' by itself does not reduce.

  A typical application are coinductive records such as streams:

    record Stream (A : Set) : Set where
      coinductive
      field
        head : A
        tail : Stream A
    open Stream

    repeat : {A : Set} (a : A) -> Stream A
    head (repeat a) = a
    tail (repeat a) = repeat a

  Again, 'repeat a' by itself will not reduce, but you can take
  a projection (head or tail) and then it will reduce to the
  respective rhs.  This way, we get the lazy reduction behavior
  necessary to avoid looping corecursive programs.

  Application patterns do not need to be trivial (i.e., variable
  patterns), if we mix with projection patterns.  E.g., we can have

    nats : Nat -> Stream Nat
    head (nats zero) = zero
    tail (nats zero) = nats zero
    head (nats (suc x)) = x
    tail (nats (suc x)) = nats x

  Here is an example (not involving coinduction) which demostrates
  records with fields of function type:

    -- The State monad

    record State (S A : Set) : Set where
      constructor state
      field
        runState : S → A × S
    open State

    -- The Monad type class

    record Monad (M : Set → Set) : Set1 where
      constructor monad
      field
        return : {A : Set}   → A → M A
        _>>=_  : {A B : Set} → M A → (A → M B) → M B


    -- State is an instance of Monad
    -- Demonstrates the interleaving of projection and application patterns

    stateMonad : {S : Set} → Monad (State S)
    runState (Monad.return stateMonad a  ) s  = a , s
    runState (Monad._>>=_  stateMonad m k) s₀ =
      let a , s₁ = runState m s₀
      in  runState (k a) s₁

    module MonadLawsForState {S : Set} where

      open Monad (stateMonad {S})

      leftId : {A B : Set}(a : A)(k : A → State S B) →
        (return a >>= k) ≡ k a
      leftId a k = refl

      rightId : {A B : Set}(m : State S A) →
        (m >>= return) ≡ m
      rightId m = refl

      assoc : {A B C : Set}(m : State S A)(k : A → State S B)(l : B → State S C) →
        ((m >>= k) >>= l) ≡ (m >>= λ a → (k a >>= l))
      assoc m k l = refl

  Copatterns are yet experimental and the following does not work:

  * Copatterns and 'with' clauses.

  * Compilation of copatterns to Haskell, JS, or Epic.

  * Projections generated by
      open R {{...}}
    are not handled properly on lhss yet.

  * Conversion checking is slower in the presence of copatterns,
    since stuck definitions of record type do no longer count
    as neutral, since they can become unstuck by applying a projection.
    Thus, comparing two neutrals currently requires comparing all
    they projections, which repeats a lot of work.

* Module parameters are now always hidden arguments in projections.
  For instance:

    module M (A : Set) where

      record Prod (B : Set) : Set where
        constructor _,_
        field
          fst : A
          snd : B
      open Prod public

    open M

  Now, the types of fst and snd are

    fst : {A : Set}{B : Set} → Prod A B → A
    snd : {A : Set}{B : Set} → Prod A B → B

  Until 2.3.2, they were

    fst : (A : Set){B : Set} → Prod A B → A
    snd : (A : Set){B : Set} → Prod A B → B

  This change is a step towards symmetry of constructors and projections.
  (Constructors always took the module parameters as hidden arguments).

* Ambiguous names in patterns are now optimistically resolved in favor
  of constructors. [Issue 822] In particular, the following succeeds now:

    module M where

      data D : Set₁ where
        [_] : Set → D

    postulate [_] : Set → Set

    open M

    Foo : _ → Set
    Foo [ A ] = A

* Anonymous where-modules are opened public. [Issue 848]

    <clauses>
    f args = rhs
      module _ telescope where
        body
    <more clauses>

  means the following (not proper Agda code, since you cannot put a
  module in-between clauses)

    <clauses>
    module _ {arg-telescope} telescope where
      body

    f args = rhs
    <more clauses>

  Example:

    A : Set1
    A = B module _ where
      B : Set1
      B = Set

    C : Set1
    C = B


Goal and error display
======================

* The error message "Refuse to construct infinite term" has been
  removed, instead one gets unsolved meta variables.  Reason: the
  error was thrown over-eagerly. [Issue 795]

* If an interactive case split fails with message

    Since goal is solved, further case distinction is not supported;
    try `Solve constraints' instead

  then the associated interaction meta is assigned to a solution.
  Press C-c C-= (Show constraints) to view the solution and C-c C-s
  (Solve constraints) to apply it. [Issue 289]

Type checking
=============

* Dependent record types and definitions by copatterns require
  reduction with previous function clauses while checking the
  current clause. [Issue 907]

  For a simple example, consider

    test : ∀ {A} → Σ Nat λ n → Vec A n
    proj₁ test = zero
    proj₂ test = []

  For the second clause, the lhs and rhs are typed as

    proj₂ test : Vec A (proj₁ test)
    []         : Vec A zero

  In order for these types to match, we have to reduce the lhs type
  with the first function clause.

  Note that termination checking comes after type checking, so be
  careful to avoid non-termination!  Otherwise, the type checker
  might get into an infinite loop.

* The implementation of the primitive primTrustMe has changed.
  It now only reduces to REFL if the two arguments x and y have
  the same computational normal form.  Before, it reduced when
  x and y were definitionally equal, which included type-directed
  equality laws such as eta-equality.  Yet because reduction is
  untyped, calling conversion from reduction lead to Agda crashes
  [Issue 882].

  The amended description of primTrustMe is (cf. release notes for 2.2.6):

    primTrustMe : {A : Set} {x y : A} → x ≡ y

  Here _≡_ is the builtin equality (see BUILTIN hooks for equality,
  above).

  If x and y have the same computational normal form, then
  primTrustMe {x = x} {y = y} reduces to refl.

  A note on primTrustMe's runtime behavior:
  The MAlonzo compiler replaces all uses of primTrustMe with the
  REFL builtin, without any check for definitional equality. Incorrect
  uses of primTrustMe can potentially lead to segfaults or similar
  problems of the compiled code.

* A buggy facility coined "matrix-shaped orders" that supported
  uncurried functions (which take tuples of arguments instead of one
  argument after another) has been removed from the termination
  checker. [Issue 787]

* Definitions which fail the termination checker are not unfolded any
  longer to avoid loops or stack overflows in Agda.  However, the
  termination checker for a mutual block is only invoked after
  type-checking, so there can still be loops if you define a
  non-terminating function.  But termination checking now happens
  before the other supplementary checks: positivity, polarity,
  injectivity and projection-likeness.
  Note that with the pragma {-# NO_TERMINATION_CHECK #-} you can make
  Agda treat any function as terminating.

* Implicit patterns of record type are now only eta-expanded if there
  is a record constructor. [Issues 473, 635]

    data D : Set where
      d : D

    data P : D → Set where
      p : P d

    record Rc : Set where
      constructor c
      field f : D

    works : {r : Rc} → P (Rc.f r) → Set
    works p = D

  This works since the implicit pattern {r} is eta-expanded to
  {c x} which allows the type of p to reduce to P x and x to be
  unified with d.  The corresponding explicit version is:

    works' : (r : Rc) → P (Rc.f r) → Set
    works' (c .d) p = D

  However, if the record constructor is removed, the same example will
  fail:

    record R : Set where
      field f : D

    fails : {r : R} → P (R.f r) → Set
    fails p = D

    -- d != R.f r of type D
    -- when checking that the pattern p has type P (R.f r)

  The error is justified since there is no pattern we could write down
  for r.  It would have to look like

    record { f = .d }

  but anonymous record patterns are not part of the language.

* Absurd lambdas at different source locations are no longer
  different. [Issue 857]
  In particular, the following code type-checks now:

    absurd-equality : _≡_ {A = ⊥ → ⊥} (λ()) λ()
    absurd-equality = refl

  Which is a good thing!

Compiler backends
=================

Tools
=====

Emacs mode
----------

* Key bindings for lots of "mathematical" characters (examples: 𝐴𝑨𝒜𝓐𝔄)
  have been added to the Agda input method.

* Key bindings for "blackboard bold" B (𝔹) and 0-9 (𝟘-𝟡) have been added
  to the Agda input method (\bb and \b[0-9]).

* Key bindings for controlling simplification/normalisation:

  [TODO: Simplification should be explained somewhere.]

  Commands like "Goal type and context" (C-c C-,) could previously be
  invoked in two ways. By default the output was normalised, but if a
  prefix argument was used (for instance via C-u C-c C-,), then no
  explicit normalisation was performed. Now there are three options:

  * By default (C-c C-,) the output is simplified.

  * If C-u is used exactly once (C-u C-c C-,), then the result is
    neither (explicitly) normalised nor simplified.

  * If C-u is used twice (C-u C-u C-c C-,), then the result is
    normalised.

  [TODO: As part of the release of Agda 2.3.4 the key binding page on
  the wiki should be updated.]

* The last step of a command like give, refine or intro is now (in
  certain cases) to move the cursor to the next goal (if any).

LaTeX-backend
-------------

* Two new color scheme options were added to agda.sty:

  \usepackage[bw]{agda}, which highlights in black and white;
  \usepackage[conor]{agda}, which highlights using Conor's colors.

  The default (no options passed) is to use the standard colors.

* If agda.sty cannot be found by the latex environment, it is now
  copied into the latex output directory ('latex' by default) instead
  of the working directory. This means that the commands needed to
  produce a PDF now is

    agda --latex -i . <file>.lagda
    cd latex
    pdflatex <file>.tex
