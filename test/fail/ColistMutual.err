Termination checking [ColistMutual.repeat,ColistMutual.∞repeat] with cutoff=0...
  target type ends in ColistMutual.CoList
termination checking body of repeat : {A : Set} → A → CoList A
termClause
  tel      = {A : Set} (a : A)
  perm     = x0,x1 -> x0,x1
termination checking clause of repeat lhs: 1 0 rhs: a ∷ ∞repeat a
termination checking function call  ∞repeat a
found call from repeat to ∞repeat
compareElim e =  $ {_} p =  1
compareElim e =  $ {_} p =  0
compareElim e =  $ a p =  1
compareElim e =  $ a p =  0
compareArgs: guardedness of call: 0
composing with guardedness 0 counting as 0
kept call from repeat 1 0
  to ∞repeat (A) (a)
  call matrix (with guardedness): [[0,.,.],[.,0,.],[.,.,0]]
termination checking body of ∞repeat : {A : Set} → A → ∞CoList A
termClause
  tel      = {A : Set} (a : A)
  perm     = x0,x1 -> x0,x1
termination checking clause of ∞repeat lhs: 1 0 out rhs: repeat a
termination checking function call  repeat a
found call from ∞repeat to repeat
compareElim e =  $ {_} p =  1
compareElim e =  $ {_} p =  0
compareElim e =  $ {_} p =  out
compareElim e =  $ a p =  1
compareElim e =  $ a p =  0
compareElim e =  $ a p =  out
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from ∞repeat 1 0 out
  to repeat (A) (a)
  call matrix (with guardedness): [[-1,.,.,.],[.,0,.,.],[.,.,0,.]]
Calls (no dot patterns): CallGraph {cg = fromList [(Call {source = 0, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 3, cols = 3} ColistMutual.agda:20,18-25]),(Call {source = 1, target = 0, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 3, cols = 4} ColistMutual.agda:23,21-27])]}
Recursion behaviours (no dot patterns):
  Function:  0
  Behaviour: [-1,0,0]
  Meta info: ColistMutual.agda:20,18-25]
  Function:  1
  Behaviour: [-1,0,0,.]
  Meta info: ColistMutual.agda:23,21-27]
Call matrices (no dot patterns):
  Source:    0
  Target:    0
  Matrix:    1 ? ?
             ? = ?
             ? ? =
  Meta info: ColistMutual.agda:20,18-25]
  Source:    0
  Target:    1
  Matrix:    = ? ?
             ? = ?
             ? ? =
             ? ? ?
  Meta info: ColistMutual.agda:20,18-25]
  Source:    0
  Target:    1
  Matrix:    1 ? ?
             ? = ?
             ? ? =
             ? ? ?
  Meta info: ColistMutual.agda:20,18-25]
  Source:    1
  Target:    0
  Matrix:    1 ? ? ?
             ? = ? ?
             ? ? = ?
  Meta info: ColistMutual.agda:23,21-27]
  Source:    1
  Target:    1
  Matrix:    1 ? ? ?
             ? = ? ?
             ? ? = ?
             ? ? ? ?
  Meta info: ColistMutual.agda:23,21-27]
ColistMutual.repeat does termination check
  target type ends in ColistMutual.∞CoList
termination checking body of repeat : {A : Set} → A → CoList A
termClause
  tel      = {A : Set} (a : A)
  perm     = x0,x1 -> x0,x1
termination checking clause of repeat lhs: 1 0 rhs: a ∷ ∞repeat a
termination checking function call  ∞repeat a
found call from repeat to ∞repeat
compareElim e =  $ {_} p =  1
compareElim e =  $ {_} p =  0
compareElim e =  $ a p =  1
compareElim e =  $ a p =  0
compareArgs: guardedness of call: 0
composing with guardedness 0 counting as 0
kept call from repeat 1 0
  to ∞repeat (A) (a)
  call matrix (with guardedness): [[0,.,.],[.,0,.],[.,.,0]]
termination checking body of ∞repeat : {A : Set} → A → ∞CoList A
termClause
  tel      = {A : Set} (a : A)
  perm     = x0,x1 -> x0,x1
termination checking clause of ∞repeat lhs: 1 0 out rhs: repeat a
termination checking function call  repeat a
found call from ∞repeat to repeat
compareElim e =  $ {_} p =  1
compareElim e =  $ {_} p =  0
compareElim e =  $ {_} p =  out
compareElim e =  $ a p =  1
compareElim e =  $ a p =  0
compareElim e =  $ a p =  out
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from ∞repeat 1 0 out
  to repeat (A) (a)
  call matrix (with guardedness): [[-1,.,.,.],[.,0,.,.],[.,.,0,.]]
Calls (no dot patterns): CallGraph {cg = fromList [(Call {source = 0, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 3, cols = 3} ColistMutual.agda:20,18-25]),(Call {source = 1, target = 0, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 3, cols = 4} ColistMutual.agda:23,21-27])]}
Recursion behaviours (no dot patterns):
  Function:  0
  Behaviour: [-1,0,0]
  Meta info: ColistMutual.agda:20,18-25]
  Function:  1
  Behaviour: [-1,0,0,.]
  Meta info: ColistMutual.agda:23,21-27]
Call matrices (no dot patterns):
  Source:    0
  Target:    0
  Matrix:    1 ? ?
             ? = ?
             ? ? =
  Meta info: ColistMutual.agda:20,18-25]
  Source:    0
  Target:    1
  Matrix:    = ? ?
             ? = ?
             ? ? =
             ? ? ?
  Meta info: ColistMutual.agda:20,18-25]
  Source:    0
  Target:    1
  Matrix:    1 ? ?
             ? = ?
             ? ? =
             ? ? ?
  Meta info: ColistMutual.agda:20,18-25]
  Source:    1
  Target:    0
  Matrix:    1 ? ? ?
             ? = ? ?
             ? ? = ?
  Meta info: ColistMutual.agda:23,21-27]
  Source:    1
  Target:    1
  Matrix:    1 ? ? ?
             ? = ? ?
             ? ? = ?
             ? ? ? ?
  Meta info: ColistMutual.agda:23,21-27]
ColistMutual.∞repeat does termination check
Termination checking [ColistMutual.bad,ColistMutual.bads] with cutoff=0...
  target type ends in ColistMutual.Tree
termination checking body of bad : Tree
termClause
  tel      =
  perm     =  -> 
termination checking clause of bad lhs: rhs: node (node [] ∷ bads)
termination checking function call  bads
found call from bad to bads
compareArgs: guardedness of call: 0
composing with guardedness 0 counting as 0
kept call from bad to bads call matrix (with guardedness): [[0]]
termination checking body of bads : ∞CoList Tree
termClause
  tel      =
  perm     =  -> 
termination checking clause of bads lhs: out rhs: bad ∷ bads
termination checking function call  bad
found call from bads to bad
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from bads out
  to bad
  call matrix (with guardedness): [[-1,.]]
termination checking function call  bads
found call from bads to bads
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from bads out
  to bads
  call matrix (with guardedness): [[-1,.]]
Calls (no dot patterns): CallGraph {cg = fromList [(Call {source = 0, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 1} ColistMutual.agda:33,25-29]),(Call {source = 1, target = 0, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 2} ColistMutual.agda:36,14-17]),(Call {source = 1, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 2} ColistMutual.agda:36,20-24])]}
Recursion behaviours (no dot patterns):
  Function:  0
  Behaviour: [-1]
  Meta info: ColistMutual.agda:33,25-29]
  Function:  1
  Behaviour: [-1,.]
  Meta info: ColistMutual.agda:36,14-17]
Call matrices (no dot patterns):
  Source:    0
  Target:    0
  Matrix:    1
  Meta info: ColistMutual.agda:33,25-29]
  Source:    0
  Target:    1
  Matrix:    =
             ?
  Meta info: ColistMutual.agda:33,25-29]
  Source:    0
  Target:    1
  Matrix:    1
             ?
  Meta info: ColistMutual.agda:33,25-29]
  Source:    1
  Target:    0
  Matrix:    1 ?
  Meta info: ColistMutual.agda:36,20-24]
  Source:    1
  Target:    1
  Matrix:    1 ?
             ? ?
  Meta info: ColistMutual.agda:36,14-17]
ColistMutual.bad does termination check
  target type ends in ColistMutual.∞CoList
termination checking body of bad : Tree
termClause
  tel      =
  perm     =  -> 
termination checking clause of bad lhs: rhs: node (node [] ∷ bads)
termination checking function call  bads
found call from bad to bads
compareArgs: guardedness of call: 0
composing with guardedness 0 counting as 0
kept call from bad to bads call matrix (with guardedness): [[0]]
termination checking body of bads : ∞CoList Tree
termClause
  tel      =
  perm     =  -> 
termination checking clause of bads lhs: out rhs: bad ∷ bads
termination checking function call  bad
found call from bads to bad
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from bads out
  to bad
  call matrix (with guardedness): [[-1,.]]
termination checking function call  bads
found call from bads to bads
compareArgs: guardedness of call: -1
composing with guardedness 0 counting as 0
kept call from bads out
  to bads
  call matrix (with guardedness): [[-1,.]]
Calls (no dot patterns): CallGraph {cg = fromList [(Call {source = 0, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 1} ColistMutual.agda:33,25-29]),(Call {source = 1, target = 0, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 2} ColistMutual.agda:36,14-17]),(Call {source = 1, target = 1, cm = CallMatrix {mat = Agda.Termination.Matrix.fromLists Size {rows = 1, cols = 2} ColistMutual.agda:36,20-24])]}
Recursion behaviours (no dot patterns):
  Function:  0
  Behaviour: [-1]
  Meta info: ColistMutual.agda:33,25-29]
  Function:  1
  Behaviour: [-1,.]
  Meta info: ColistMutual.agda:36,14-17]
Call matrices (no dot patterns):
  Source:    0
  Target:    0
  Matrix:    1
  Meta info: ColistMutual.agda:33,25-29]
  Source:    0
  Target:    1
  Matrix:    =
             ?
  Meta info: ColistMutual.agda:33,25-29]
  Source:    0
  Target:    1
  Matrix:    1
             ?
  Meta info: ColistMutual.agda:33,25-29]
  Source:    1
  Target:    0
  Matrix:    1 ?
  Meta info: ColistMutual.agda:36,20-24]
  Source:    1
  Target:    1
  Matrix:    1 ?
             ? ?
  Meta info: ColistMutual.agda:36,14-17]
ColistMutual.bads does termination check
ColistMutual.agda:39,1-6
The right-hand side can only be omitted if there is an absurd
pattern, () or {}, in the left-hand side.
when checking that the clause CRASH has type _16
